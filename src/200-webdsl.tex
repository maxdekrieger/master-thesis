% !TEX root = document.tex

\chapter{\label{chap:webdsl}WebDSL}

  In this chapter we describe WebDSL. WebDSL is a domain-specific language for developing web applications. The language incorporates ideas from various web programming frameworks and produces code for all tiers in a web application \autocite{Groenewegen2020}. Ever since its introduction over 15 years ago \autocite{Visser2007}, WebDSL has been a vehicle for research (cite some papers here) and on top of that, it is the programming language underpinning several applications used daily by thousands of users. Examples of WebDSL applications include but are not limited to:

  \begin{itemize}
    \item \textbf{WebLab}: An online learning management system, used by the Delft University of Technology.
    \item \textbf{conf.researchr.org}: A domain-specific content management system for conferences, used by all ACM SIGPLAN and SIGSOFT conferences.
    \item \textbf{researchr.org}: A platform for finding, collecting, sharing, and reviewing scientific computer science related publications.
  \end{itemize}

  In WebDSL, all aspects of web programming are defined in the same language which creates an opportunity for strong static consistency checking \autocite{Hemel2011}. The data model is defined using entities, which are automatically translated to a database representation. These entities can be passed as arguments of pages without the need to explicitly fetch data from the database. Large amounts of boilerplate code are abstracted over by WebDSL, by providing built-in but customizable functionality for access control, relations between entities and data validation. This combination of features allows WebDSL developers to efficiently create functioning prototypes while providing the functionality to make it scale and customizable.

  The rest of this chapter showcases the different aspects of WebDSL and zooms in on its non-trivial features. First, in \cref{sec:ui} we will describe how WebDSL offers functionality for creating web user interfaces. Next, in \cref{sec:data-model} we illustrate how the langauge manages data models. Thirdly, \cref{sec:access-control} contains information about WebDSL's solution for access control and in \cref{sec:functions} we highlight interesting aspects of its general-purpose object oriented function code. We conclude this chapter by elaborating on the current implementation of the WebDSL compilation chain in \cref{sec:current-implementation}.

  \section{\label{sec:ui}User Interfaces}

    The user interface of a WebDSL application is the part of the system that the user interacts with. Through the user interface, users are able to create, view, update or delete data.

    \subsection{\label{subsec:building-blocks}Building Blocks: Pages, Templates and Template Elements}

      A WebDSL application is exposed to the user via pages that are accessible from the browser. In WebDSL, pages have a name and can optionally take arguments that directly correspond with the path of the webpage.

      Templates are reusable definitions of user interface code that are not accessible directly by users. Templates can be included on pages and can be nested in other templates. \Cref{fig:webdsl-pages-and-templates} shows an example of an application with two pages, the root page and the \texttt{recipe} page, with navigation between them and a reusable template called \texttt{linkToRecipe} that creates a link to the recipe page with an argument of type string. The recipe page also takes one argument of type string which is visible in the URL path.

      \begin{figure}
        \begin{subfigure}[t]{0.45\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application app
  page root {
    title { "Cookbook" }

    header { "Recipes" }

    linkToRecipe("Lasagne")
    linkToRecipe("Pancakes")
    linkToRecipe("Tomato Soup")
  }

  page recipe(s : String) {
    title { "Cookbook: ~s" }

    navigate root() {
      "Back to homepage"
    }

    header { "~s" }

    "Welcome to the recipe page for ~s!"
  }

  template linkToRecipe(s : String) {
    par {
      navigate recipe(s) {
        "View recipe for ~s"
      }
    }
  }
          \end{minted}
          \caption{\label{fig:webdsl-pages-and-templates-webdsl}WebDSL code}
        \end{subfigure}
        \begin{subfigure}[t]{0.55\textwidth}
          \begin{subfigure}[t]{1\textwidth}
            \capstart
            \includegraphics[width=\textwidth]{../img/webdsl-pages-templates-root}
            \caption{\label{fig:webdsl-pages-and-templates-root-page}Root page}
          \end{subfigure}
          \begin{subfigure}[t]{1\textwidth}
            \capstart
            \includegraphics[width=\textwidth]{../img/webdsl-pages-templates-recipe}
            \caption{\label{fig:webdsl-pages-and-templates-recipe-page}Recipe page}
          \end{subfigure}
        \end{subfigure}
      \caption{\label{fig:webdsl-pages-and-templates}An example of a simple WebDSL application with two pages, navigation and reusable templates.}
      \end{figure}

      The \texttt{navigate} calls are references to other pages in the application. Because all pages are known at compile time, WebDSL ensures that all navigation within an application refers to existing pages, and that the passed types are correct. Referring to a non-existing page or passing the wrong argument types would show an error in the WebDSL development environment and while compiling the application.
      
      Other than pages and templates and navigation between pages, the application uses various calls to built-in template such as \texttt{title}, \texttt{header} and \texttt{par}. These built-in templates are translated their respective HTML elements \texttt{<title></title>}, \texttt{<h1></h1>} and \texttt{<p></p>}. WebDSL also supports directly listing all HTML elements with its usual syntax such as \texttt{<div>"text"</div>}, but generally using template-style code such as \texttt{div \{ "text" \}} is the convention in WebDSL.

      Outputting text on a webpage in WebDSL can be done by typing the text between code in a template or page, as is shown in the example cookbook application of \cref{fig:webdsl-pages-and-templates}.

      Using the concepts described in this subsection, developers are able to create static websites with WebDSL. However, a powerful aspect of WebDSL is its ability to create dynamic pages without requiring much boilerplate code.

    \subsection{\label{subsec:request-processing}Request processing and Action Code}

      HTML has a notion of forms and inputs that can be submitted to a webserver, after which it returns a result. WebDSL code compiles to HTML forms and takes away the responsibility of manually linking the input data to variables. \Cref{fig:webdsl-forms} shows an example of the cookbook application where the user is able to enter a name in an input field and browse to that recipe.

      \begin{figure}
        \begin{subfigure}[t]{0.45\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application app
  page root {
    var s : String

    title { "Cookbook" }

    header { "Recipes" }

    form {
      par {
        "Enter a recipe name:"
        input(s)
      }
      submit toRecipe() { "Go!" }
    }

    action toRecipe() {
      return recipe(s);
    }
  }

  page recipe(s : String) {
    title { "Cookbook: ~s" }

    navigate root() { "Back to homepage" }

    header { "~s" }

    "Welcome to the recipe page for ~s!"
  }
          \end{minted}
          \caption{\label{fig:webdsl-forms-webdsl}WebDSL code}
        \end{subfigure}
        \begin{subfigure}[t]{0.55\textwidth}
          \begin{subfigure}[t]{1\textwidth}
            \capstart
            \includegraphics[width=\textwidth]{../img/webdsl-forms-root}
            \caption{\label{fig:webdsl-forms-root-page}Root page}
          \end{subfigure}
          \begin{subfigure}[t]{1\textwidth}
            \capstart
            \includegraphics[width=\textwidth]{../img/webdsl-forms-recipe}
            \caption{\label{fig:webdsl-forms-recipe-page}Recipe page}
          \end{subfigure}
        \end{subfigure}
      \caption{\label{fig:webdsl-forms}An example of a WebDSL application that uses a form for navigation.}
      \end{figure}

      \Cref{fig:webdsl-forms} no longer contains a fixed list with links to all possible recipes as in \cref{fig:webdsl-pages-and-templates} but now uses a form with an input and submits an action when the user presses a button. The root page contains a variable declaration as the first line, which defaults to an empty string. In the form later on the page, this variable is passed to an input element. After the input, the form has a button that send a request to the webserver to execute the action \texttt{toRecipe} when it is pressed. When this request is sent to the server, the data entered in the input field is linked to variable \texttt{s} by WebDSL, and the action code is able to use this in its body. The return value of an action is the page that should be shown as response. In the example of \cref{fig:webdsl-forms}, the result of executing the action is to show the \texttt{recipe} page with the input that the user has entered in the form.

      WebDSL also sanitizes the input that the user submits using the form. If the user was to submit the form with input \texttt{another/path/}, this input would be sanitized and rendered correctly on the recipe page, instead of navigation to an unknown path.

      Note that WebDSL usually has declare-before-use semantics inside in page, templates or function bodies, but actions can be declared and resolved anywhere in a page or template definition.

    \subsection{\label{subsec:template-overloading}Template Overloading}

      Templates in WebDSL must have a unique combination of name and argument types. This means that similar to functions in Java, WebDSL templates support overloading the same template with different arguments. The built-in \texttt{input} template that we used in previous subsection is an example of this. In \cref{fig:webdsl-forms} of previous subsection, a string argument is passed to the \texttt{input} template which rendered a text field on the resulting web page.

      \Cref{fig:webdsl-template-overloading} shows an example of template overloading. The \texttt{describe} template is defined multiple times for different argument types. The \texttt{input} template is provided by the WebDSL standard library and also shows different input elements for different types.

      \begin{figure}
        \begin{subfigure}[t]{0.45\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application app
  page root {
    var s : String
    var b : Bool
    var t : Text
    var d : Date

    title { "Input Examples" }

    header { "Input Examples" }

    form {
      par {
        describe(s)
        input(s)
      }
      par {
        describe(b)
        input(b)
      }
      par {
        describe(t)
        input(t)
      }
      par {
        describe(d)
        input(d)
      }
    }
  }

  template describe(s : String) { "String input:" }
  template describe(b : Bool)   { "Bool input:"   }
  template describe(t : Text)   { "Text input:"   }
  template describe(d : Date)   { "Date input:"   }
          \end{minted}
          \caption{\label{fig:webdsl-template-overloading-webdsl}WebDSL code}
        \end{subfigure}
        \begin{subfigure}[t]{0.55\textwidth}
          \capstart
          \includegraphics[width=\textwidth]{../img/webdsl-template-overloading}
          \caption{\label{fig:webdsl-template-overloading-page}Resulting page}
        \end{subfigure}
      \caption{\label{fig:webdsl-template-overloading}An example of template overloading in WebDSL with inputs and descriptions.}
      \end{figure}

      In WebDSL, multiple text-based types such as \texttt{String}, \texttt{Text}, \texttt{WikiText} and \texttt{Secret} are all compatible with the base type \texttt{String}. When the arguments are passed to a template, it resolves the most specific template. An example of this is that \texttt{describe(t)} in \cref{fig:webdsl-template-overloading} is compatible with \texttt{String} and \texttt{Text}, but it resolves to the definition with a \texttt{Text} argument.

      When a template call has multiple arguments, it resolves to the template where all arguments are the most specific. If there is one template definition where the first argument is more specific, and another definition where the second argument is more specific, this is incorrect code and the WebDSL development environment shows an error to the developer.

    \subsection{\label{subsec:ajax}Ajax}

      To enable refreshing or replacing parts of a page with new content that is fetched from the server, WebDSL has support for placeholders that can be populated with content using \textit{asynchronous JavaScript and XML} (ajax). Without ajax functionalities, refreshing data on a page would require a full page refresh.

      \Cref{fig:webdsl-ajax} shows an example of a WebDSL application that defines a placeholder named \texttt{ph} which is empty initially. On the bottom of the page, a clickable link with an inline action is defined. When the action is executed, it will replace the contents of the placeholder with the content of the ajax-enabled template \texttt{hello()}. The calling of the action does not incur a full page refresh, but instead fires an asynchronous request that returns the content of the ajax template, after which it is replaced using JavaScript.

      \begin{figure}
        \begin{subfigure}[t]{0.45\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application app
  page root {
    title { "Ajax Example" }

    header { "Ajax Example" }

    par {
      placeholder ph {}
    }

    submitlink action {
      replace(ph, hello());
    } { "Replace" }
  }

  ajax template hello {
    "Hello!"
  }
          \end{minted}
          \caption{\label{fig:webdsl-ajax-webdsl}WebDSL code}
        \end{subfigure}
        \begin{subfigure}[t]{0.55\textwidth}
        \begin{subfigure}[t]{1\textwidth}
          \capstart
          \includegraphics[width=0.75\textwidth]{../img/webdsl-ajax-1}
          \caption{\label{fig:webdsl-ajax-page-1}Resulting page}
        \end{subfigure}
        \begin{subfigure}[t]{1\textwidth}
          \capstart
          \includegraphics[width=0.75\textwidth]{../img/webdsl-ajax-2}
          \caption{\label{fig:webdsl-ajax-page-2}After clicking the link}
        \end{subfigure}
      \end{subfigure}[t]
      \caption{\label{fig:webdsl-ajax}An example of placeholders and ajax actions in WebDSL.}
      \end{figure}

      WebDSL automatically takes care of the necessary structure to enable this functionality, such as identifiers of DOM elements, JavaScript code to query the server and JavaScript code to replace the correct elements.

      As opposed to regular templates, ajax-enabled template are able to be requested on the server using a specific endpoint. The exact details of how this endpoint looks is only relevant for generated code of the WebDSL compiler, but WebDSL developers should pay attention to the fact that ajax-enabled content must be projected with proper access control rules (see \cref{sec:access-control}) to prevent exposing sensitive content.

    \subsection{\label{subsec:redefines}Dynamically Scoped Redefines}

      As last part of the user interface section, we give an example of dynamically scoped redefines in WebDSL. WebDSL templates are able to be redefined (i.e. overridden) in the context of another template.

      \Cref{fig:webdsl-template-overriding} shows an example of a dynamically scoped redefinition of a template. In the figure, \texttt{templateB} redefines \texttt{templateA}, resulting in the overridden template being rendered when it is called within \texttt{templateB}. To prove that this is scoped, \texttt{templateA} is called before and after \texttt{templateB} and it renders the same (original) text. In the example of \cref{fig:webdsl-template-overriding}, the redefined template is called directly from the template where it is redefined but it has the same effect when it would be called in nested templates.

      \begin{figure}
        \begin{subfigure}[t]{0.45\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application app
  page root {
    title { "Override Template" }

    header { "Override Template" }

    templateA
    templateB
    templateA
  }

  template templateA {
    par {
      "I'm Template A!"
    }
  }

  template templateB {
    // override template A
    template templateA {
      par {
        "I'm Template A inside template B!"
      }
    }

    par {
      "I'm Template B!"
    }
    templateA
  }
          \end{minted}
          \caption{\label{fig:webdsl-template-overriding-webdsl}WebDSL code}
        \end{subfigure}
        \begin{subfigure}[t]{0.55\textwidth}
          \capstart
          \includegraphics[width=\textwidth]{../img/webdsl-template-overriding}
          \caption{\label{fig:webdsl-template-overriding-page}Resulting page}
        \end{subfigure}
      \caption{\label{fig:webdsl-template-overriding}An example of template overriding in WebDSL.}
      \end{figure}

      Apart from this redefinition of templates inside the context of other templates, WebDSL also has a notion of a one-time global redefinition. This is done using the keyword \texttt{override} on a template in the global scope. The WebDSL standard library contains many definitions that are able to be used by developers, such as an access-denied page, a login template or the input templates that are used in \cref{fig:webdsl-template-overloading}. Using the \texttt{override} keyword, developers are able to customize the style and behaviour of these definitions.

  \section{\label{sec:data-model}Data Model}

    The data model of a WebDSL application is defined using entities. Entities can have properties and relations with other entities. WebDSL translates the entities to database tables and columns such that any data stored in entities is persisted. The communication with the database is abstracted by WebDSL, allowing WebDSL developers to directly access, manipulate and pass around entity values.

    \Cref{fig:webdsl-data-model-simple} shows an example of an application with stored recipes. A \texttt{Recipe} has two properties: a name and a duration. The application is similar to the earlier representation from \cref{fig:webdsl-pages-and-templates} where a recipe was simply defined by its name, encoded as a String. The representation using entities now defines the \texttt{recipe} page which takes a Recipe as argument, demonstrating how entities are represented in the WebDSL type system.

    \begin{figure}
      \begin{subfigure}[t]{0.45\textwidth}
        \begin{minted}[firstline=1]{\webdsl}
application cookbook

section data model
  entity Recipe {
    name            : String
    minutesRequired : Int
  }

  init {
    var r1 := Recipe {
      name := "Lasagne",
      minutesRequired := 60
    };
    var r2 := Recipe {
      name := "Pancakes",
      minutesRequired := 20
    };
    var r3 := Recipe {
      name := "Tomato Soup",
      minutesRequired := 40
    };
  }

section user interface
  page root {
    title { "Cookbook" }
    header { "Recipes" }
    for (r : Recipe) {
      par {
        navigate recipe(r) { "View recipe for ~r.name" }
      }
    }
  }

  page recipe(r : Recipe) {
    title { "Cookbook: ~r.name" }
    navigate root() { "Back to homepage" }
    header { "~r.name" }
    par {
      "Welcome to the recipe page for ~r.name!"
    }
    par {
      "Minutes required: ~r.minutesRequired"
    }
  }
        \end{minted}
        \caption{\label{fig:webdsl-data-model-simple-webdsl}WebDSL code}
      \end{subfigure}
      \begin{subfigure}[t]{0.55\textwidth}
        \capstart
        \includegraphics[width=\textwidth]{../img/webdsl-data-model-simple-root}
        \caption{\label{fig:webdsl-data-model-simple-root}Root page}
      \end{subfigure}
      \begin{subfigure}[t]{1\textwidth}
        \capstart
        \includegraphics[width=\textwidth]{../img/webdsl-data-model-simple-recipe}
        \caption{\label{fig:webdsl-data-model-simple-recipe}Recipe page}
      \end{subfigure}
    \caption{\label{fig:webdsl-data-model-simple}An example of template overriding in WebDSL.}
    \end{figure}

    The \texttt{init\{\}} block in the global scope of \cref{fig:webdsl-data-model-simple} is executed only once, and often used to seed the database.

    Furthermore, the root page of \cref{fig:webdsl-data-model-simple} uses a for-loop to iterate over all existing instances of an entity; Recipes in our case. It is uncommon to loop over \textit{all} entities, thus WebDSL supports a filter in the for-loop similar to SQL syntax.

    \begin{itemize}
      \item Inheritance
      \item Extending entities
    \end{itemize}

  \section{\label{sec:access-control}Access Control}

    \begin{itemize}
      \item Syntax
      \item Inferred visibility
      \item Nested rules
      \item Pointcuts
    \end{itemize}

  \section{\label{sec:functions}Functions}

    \begin{itemize}
      \item Syntax
      \item Entities as classes
      \item Hooks for entity setters
      \item Extending functions
    \end{itemize}

  \section{\label{sec:current-implementation}Current Implementation}

    \subsection{\label{subsec:spoofax}Spoofax Language Workbench}

      \begin{itemize}
        \item History
        \item Goal
        \item Achievements
      \end{itemize}

    \subsection{\label{subsec:current-implementation}Current Implementation of WebDSL}

      \begin{itemize}
        \item Large Stratego specification where desugaring, static analysis, optimization and code-generation are interleaved (exaggeration?)
        \item Side effects using dynamic rules.
        \item Unexpected consequences of changes due to limited static analysis in untyped setting.
      \end{itemize}

      Go over some interesting WebDSL features and how they are implemented:
      \begin{itemize}
        \item Access control
        \item Template overloading and overriding
        \item Entity extension
      \end{itemize}

  \section{\label{sec:modernization}Modernization goal}

    \begin{itemize}
      \item A complete and maintainable SDF3 and Statix specification of WebDSL.
      \item Gather insight into the capabilities, elegance and performance of SDF3 and Statix.
      \item Profit from performance boosts of SDF3 and Statix, as opposed to deprecated SDF2 and handcrafted static analysis in Stratego.
    \end{itemize}
