% !TEX root = document.tex

\chapter{\label{chap:statix}WebDSL in Statix}

  In this chapter, we elaborate on the implementation of the WebDSL static semantics in Statix, using the examples from \cref{chap:webdsl} as a basis. First, we introduce the meta-DSL Statix. Secondly, we describe the implementation of the simple type system that is the core of WebDSL. Next, we address and discuss the challenges faced while implementing non-trivial WebDSL features in Statix and lastly we reflect on the developer experience of using Statix to implement static analyses.

  \section{\label{sec:statix}Introduction to Statix}

    Statix is a constraint-based declarative language for the specification of type systems, introduced in 2018 \autocite{VanAntwerpen2018}. Since then, the meta-DSL Statix has become a part of the Spoofax Language Workbench and allows language developers to implement static analyses to provide language users with useful hints, warnings and errors.

    A Statix specification consists of rules over terms that define constraints. Additionally, Statix rules build and query a \textit{scope graph} \autocite{Neron2015} that provides a language-agnostic representation of a program.

    \subsection{Language Signature}

      \begin{wrapfigure}{r}{0.58\linewidth}
        \vspace{-15pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    sorts
      Application
      Exp
    
    constructors
      Application : Exp       -> Application
      True        :              Exp
      False       :              Exp
      Int         : string    -> Exp
      Add         : Exp * Exp -> Exp
        \end{minted}
        \caption{\label{fig:statix-signatures}Language signature in Statix}
        \vspace{-10pt}
      \end{wrapfigure}

      Consider a language consisting of Booleans, integers and addition, for which we want to create a type-checker with Statix. First, Statix requires us to declare all types and sorts that we will be using in the rules. The corresponding Statix code is shown in \cref{fig:statix-signatures}.

      So far, our specification consists of two sorts. The \texttt{Application} sort defines the entry point of our language, it has one constructor with an identical name. Next, the sort \texttt{Exp} describes what expressions are allowed. It has four constructors: the Boolean values \texttt{True} and \texttt{False}, \texttt{Int} which requires an integer literal as subterm, and lastly \texttt{Add} which takes two nested expressions as subterms. Examples of valid input according to our defined signature are shown in \cref{fig:statix-valid-input}.

      \begin{figure}[H]
        \begin{minted}[frame=single]{javascript}
  Application(True())                    // true
  Application(Int("42"))                 // 42
  Application(Add(Int("40"), Int("2")))  // 40 + 2
  Application(Add(Int("40"), False()))   // 40 + false
        \end{minted}
        \caption{\label{fig:statix-valid-input}Valid input terms for the described language}
      \end{figure}

    \subsection{Semantic Types}

      Not all of the valid input terms according to our signature are well-typed. For example, the last term shown in \cref{fig:statix-valid-input} features an addition of the integer literal \texttt{40} and the Boolean value \texttt{False}. Using Statix' constraint solving capabilities, we would like to give feedback to the programmer that the input is ill-typed.

      Given the code in \cref{fig:statix-signatures}, our Statix specification does not yet generate any constraints. Constraints we would like to generate using Statix rules, are that a program must be well-typed and in order for an addition expression to be well-typed, its two subterms must be of integer type.

      \begin{wrapfigure}{r}{0.5\linewidth}
        \vspace{-20pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    sorts
      TYPE
    
    constructors
      BOOL : TYPE
      INT  : TYPE
        \end{minted}
        \caption{\label{fig:statix-type-signatures}Statix signature for Boolean and integer types}
        \vspace{-40pt}
      \end{wrapfigure}

      To reason about the types of expressions and use them in constraints, we must first define them in our specification, as shown in \cref{fig:statix-type-signatures}. To distinguish input sorts and constructors from semantic types that we will use in our constraints, those sorts and constructors are defined in upper-case. With the new \texttt{TYPE} sort that has two constructors: \texttt{BOOL} and \texttt{INT}, we can start generating constraints on input terms.

    \subsection{Predicates and Rules}

      \Cref{fig:statix-basic-rules} lists the Statix predicates and rules required to generate the constraints we want to be satisfied in order for a program to be well-typed. 

      \begin{figure}[H]
        \begin{minted}[]{\statix}
  module x
  rules

    applicationOk : Application
    applicationOk(Application(e)) :- { T }
      typeOfExp(e) == T.

    typeOfExp : Exp -> TYPE
    typeOfExp(True()) = BOOL().
    typeOfExp(False()) = BOOL().
    typeOfExp(Int(_)) = INT().
    typeOfExp(Add(e1, e2)) = INT() :-
      typeOfExp(e1) == INT(),
      typeOfExp(e2) == INT().
        \end{minted}
        \caption{\label{fig:statix-basic-rules}Statix predicates and rules for typing Booleans, integers and addition}
      \end{figure}

      The type of all Statix predicates must be explicitly declared, for example the \texttt{applicationOk} predicate on line 3 specifies that all rules of \texttt{applicationOk} match exactly one constructor \texttt{Application}. An instantiation of the \texttt{applicationOk} predicate is on line 4. In prose English it would read ``An application is well-typed, given that for some type \texttt{T}, the expression \texttt{e} has type \texttt{T}''.
      
      The other Statix rule in our small example specification is a \textit{functional predicate}, meaning that it returns a value. All but the last rules of the \texttt{typeOfExp} predicate compute a \texttt{TYPE} for a given expression, without conditions. The last rule of the example does have two conditions, in prose English it would read ``\texttt{e1} plus \texttt{e2} is of type \texttt{INT}, given that \texttt{e1} is of type \texttt{INT} and \texttt{e2} is of type \texttt{INT}''.

    \subsection{Building and Querying Scope Graphs}

      When we expand our small example language with let-bindings and we want to add typing rules for this new construct, we encounter a new feature in Statix. To facilitate typing rules for name binding, Statix uses \textit{scope graphs} \autocite{Neron2015}. Scope graphs are built out of three components: scopes, edges and declarations.

      \begin{figure}[h]
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope] at(-1, 0) {s1};
            \node (x_1) [decl]  at(1, 0) {x};

            \draw[decl edge] (s_1.east) -- (x_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example1}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (x_1) [decl]  at(1, 0) {x};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_1.east) -- (x_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example2}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (x_1) [decl]  at(1, 0) {x};
            \node (y_1) [decl]  at(1, -1.5) {y};
            \node (z_1) [decl]  at(1, -2.5) {z};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_1.east) -- (x_1.west);
            \draw[decl edge] (s_2.east) -- (y_1.west);
            \draw[decl edge] (s_2.east) -- (z_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example3}}
        \end{subfigure}
        \caption{\label{fig:scope-graph-examples}Scope graph examples}
      \end{figure}

      \Cref{fig:scope-graph-examples} showcases three examples of scope graphs. \Cref{fig:scope-graph-example1} consists of a single scope \texttt{s1} with declaration \texttt{x}. The second example, \cref{fig:scope-graph-example2}, consists of two scopes: a root scope \texttt{s1} with again a declaration of \texttt{x}, and a scope \texttt{s2} with an outgoing edge to \texttt{s1} labeled \texttt{P}. The last example again has two scopes, with one declaration in \texttt{s1} and two declarations in \texttt{s2}.

      \begin{wrapfigure}{r}{0.5\linewidth}
        \vspace{-20pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    constructors
      Let : string * Exp * Exp -> Exp
      Var : string             -> Exp

    name-resolution
      labels
        P

    relations
      var : string * TYPE
        \end{minted}
        \caption{\label{fig:statix-let-binding-signatures}Statix signature for let-bindings}
        % \vspace{-40pt}
      \end{wrapfigure}

      The first step in implementing let-bindings in Statix is adding the signature. In addition to the new constructors on line 3 and 4, we now introduce an edge label \texttt{P} and the relation \texttt{var}. The edge labels defined in the constructor provide the set of allowed labels to use in rules later on. The relation \texttt{var} on line 11 specifies that any declaration made under the \texttt{var} relation in a scope, maps an identifier to its type.
      
      For illustration purposes, when we want to encode a single scope with two variable declarations, \texttt{x} of type \texttt{INT} and \texttt{b} of type \texttt{BOOL}, its scope graph would be as shown in \cref{fig:scope-graph-relations-example}.

      \begin{figure}[h]
        \centering
        \begin{tikzpicture}
          \node (s_1) [scope]   at(0, 0) {s1};
          \node (x_1) [decl]  at(3, 0.5) {x : INT()};
          \node (b_1) [decl]  at(3, -0.5) {b : BOOL()};

          \draw[decl edge] (s_1.east) -- (x_1.west) node[midway, sloped, fill=white] {var};
          \draw[decl edge] (s_1.east) -- (b_1.west) node[midway, sloped, fill=white] {var};
        \end{tikzpicture}
        \caption{\label{fig:scope-graph-relations-example}A scope graph containing a single scope with two declared variables}
      \end{figure}

      In Statix, scopes can be passed around as data. When we are evaluating an expression in our extended language, we now also want to pass the current scope. Whenever we encounter a let-binding, we want to create a new scope, link it to the previous one, declare the variable in the new scope and evaluate the expression. When we want to evaluate a variable expression, we want to query the scope graph and get its type. The Statix rules to reflect this are shown in \cref{fig:statix-let-binding-rules}.

      \begin{figure}[h]
        \begin{minted}[]{\statix}
  module x
  rules
    applicationOk : Application
    applicationOk(Application(e)) :- { s T }
      new s,
      typeOfExp(s, e) == T.

    typeOfExp : scope * Exp -> TYPE
    // ... previous rules
    typeOfExp(s, Let(x, e1, e2)) = T2 :- { s_let T1 }
      typeOfExp(s, e1) == T1,
      new s_let,
      s_let -P-> s,
      !var[x, T1] in s_let,
      T2 == typeOfExp(s_let, e2).

    typeOfExp(s, Var(x)) = T :-
      query var filter P*
                and { x' :- (x', _) == (x, _) }
                min $ < P
                and true
                in s |-> [(_, (_, T))].
        \end{minted}
        \caption{\label{fig:statix-let-binding-rules}Statix rules for let-bindings}
      \end{figure}

      \Cref{fig:statix-let-binding-rules} showcases various previously unexplained constructs:
      \begin{itemize}
        \item \textbf{Line 4} creates a new scope \texttt{s}. This scope is the root scope since it is created once at the start of an application and is not linked to any other scope.
        \item \textbf{Line 7} shows the new signature of the \texttt{typeOfExp} functional predicate. Given a scope and an expression, the rules of \texttt{typeOfExp} will compute the type of the expression.
        \item \textbf{Line 9-14} gives the typing rule of a let-binding. Given that the let-binding is of form \texttt{let x = e1 in e2}, the rule:
        \begin{itemize}
          \item computes the type of \texttt{e1} on line 10;
          \item creates a new scope \texttt{s\_let} on line 11 for the body of the let to evaluate in;
          \item declares variable \texttt{x} with associated type \texttt{T1} in the newly created scope \texttt{s\_let};
          \item computes the type of \texttt{e2} and this is the result of the rule.
        \end{itemize}
        \item \textbf{Line 16-21} holds the implementation of the variable typing rule. It executes a query with the following properties:
        \begin{itemize}
          \item It only returns entries in the \texttt{var} relation (line 17)
          \item It may follow zero or more \texttt{P} edge labels to other scopes (line 17);
          \item It only returns declarations under the same identifier as \texttt{x} (line 18);
          \item It prefers local declarations over declarations for which P edges must be followed (line 19);
          \item Shadowing according to the shadowing rules of line 19 is enabled (line 20);
          \item The query starts in the passed scope \texttt{s} (line 21);
          \item The result may only be one declaration (line 21).
        \end{itemize}
      \end{itemize}

      \Cref{fig:statix-let-binding-example} shows a possible input and the constructed scope graph after the constraints have been solved.

      \begin{figure}[h]
        \begin{subfigure}[b]{0.33\textwidth}
          \begin{minted}{javascript}
    let x = 1 in
      let y = x in
        x + y
          \end{minted}
          \caption{\label{fig:statix-let-binding-example-input}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \begin{minted}{javascript}
  Application(
    Let(
      "x", Int("1"), Let(
        "y", Var("x"), Add(
          Var("x"),
          Var("y")
        )
      )
    )
  )
          \end{minted}
          \caption{\label{fig:statix-let-binding-example-term}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (s_3) [scope]   at(-1, -4) {s2};
            \node (x_1) [decl]  at(2, -2) {x};
            \node (y_1) [decl]  at(2, -4) {y};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[scope edge] (s_3.north) -- (s_2.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_2.east) -- (x_1.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_3.east) -- (y_1.west) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:statix-let-binding-example-sg}}
        \end{subfigure}
        \caption{\label{fig:statix-let-binding-example}Constructed scope graph after the example specification solved its contraints}
      \end{figure}

  \section{\label{sec:simple-type-systems}Encoding the WebDSL Basics}

    \subsection{\label{subsec:simple-constants}Constant Expressions}

      \begin{itemize}
        \item Typing rules
        \item Type compatibility
      \end{itemize}

    \subsection{\label{subsec:simple-variables}Variables}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Declare before use
        \item Shadowing
      \end{itemize}

    \subsection{\label{subsec:simple-entities}Entities and properties}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{\label{subsec:simple-functions}Functions}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{\label{subsec:simple-pages}Pages and Templates}

      \begin{itemize}
        \item Declaration and resolving
      \end{itemize}

  \section{\label{sec:inheritance}Inheritance}

    \subsubsection{Linking the Scopes}
      The implementation of inheritance requires the scope of the sub- and super-entity to be connected such that Statix queries can resolve to declarations from the super-entity when necessary. To achieve this, we introduce an edge label \texttt{INHERIT} as shown in listing \emph{TO-DO}.
      \begin{minted}[firstline=3]{\statix}
  module x
  signature
    name-resolution
      labels
        INHERIT // inherit edge label for subclasses
      \end{minted}
      Declarations of sub-entities will generate constraints as shown in listing \emph{TO-DO}.
      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity super' s_super}
      resolveEntity(s_global, super) == [(_, (super', ENTITY(s_super)))],
      new s_entity, s_entity -INHERIT-> s_super,
      noCircularInheritance(s_entity),
      declEntity(s_global, s_entity, x, bodydecs),
      @super.ref := super'.
      \end{minted}
      First of all, the super-entity refered to in the declaration must refer to an existing entity in the scope graph. Secondly, the new scope belonging to the sub-entity \texttt{s\_entity} is linked to the scope of the super class \texttt{s\_super} via an \texttt{INHERIT} edge. Finally, some additional constraints are generated to make sure no circular inheritance exists and constraints for the entity body declarations of the sub-entity are generated.

      Previously, the resolving of variables was done using the query as shown in listing \emph{TO-DO}
      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveVar(s, x) = ps :-
      query var filter P* F* IMPORT*
                and { x' :- x' == (x, _) }
                min $ < P, P < F, F < IMPORT
                and true
                in s |-> ps.
      \end{minted}
      The new query in listing \emph{TO-DO} reflects the addition of the \texttt{EXTEND} label. The addition of \texttt{INHERIT*} in the query filter makes all variables declared in ancestors reachable.
      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveVar(s, x) = ps :-
      query var filter P* F* INHERIT* IMPORT*
                and { x' :- x' == (x, _) }
                min $ < P, P < F, F < INHERIT, INHERIT < IMPORT
                and true
                in s |-> ps.
      \end{minted}

    \subsubsection{Overwriting Functions}
      Generally, overwriting functions is not allowed in WebDSL. Entity functions are an exception to this such that entity function definitions shadow global function definitions. With the introduction of inheritance there comes another exception, namely that sub-entities are allowed to overwrite function definitions of their ancestors.

      Previously, the resolving of entity functions was done using the query as shown in listing \emph{TO-DO} below.

      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveEntityFunction(s, x) = ps :-
      query function filter e
                      and { x' :- x' == (x, _) }
                      min
                      in s |-> ps.
      \end{minted}

      With the introduction of entity inheritance, the path well-formedness over edge labels should be tweaked such that functions from ancestors are in scope. Changing \texttt{filter e} to \texttt{filter INHERIT*} accomplishes this. The resulting query is in listing \emph{TO-DO} below.

      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveEntityFunction(s, x) = ps :-
      query function filter INHERIT*
                      and { x' :- x' == (x, _) }
                      min /* */
                      in s |-> ps.
      \end{minted}

      This query definition works perfectly when sub-entities do not overwrite functions. When a sub-entity does define a function that is already defined in one of its ancestors, resolving the entity function gives two results while we would like only one result, namely the overwritten function defined in the sub-entity. To tackle this challenge, we defined a Statix anonymous shadowing rule combined with a label order. This ensures that when two functions with the same name and argument types exist, only the most specific (i.e. the least inheritance edges) is returned. This is implemented as shown in listing \emph{TO-DO}.

      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveEntityFunction(s, x) = ps :-
      query function filter INHERIT*
                      and { x' :- x' == (x, _) }
                      /* prioritize local scope over inheritance */
                      min $ < INHERIT
                      /* shadow when function name and argument types match */
                      and {
                      (f, FUNCTION(args, _, _)),
                      (f, FUNCTION(args, _, _))
                      }
                      in s |-> ps.
      \end{minted}

    \subsubsection{Entity Type Compatibility}
      A great perk of having inheritance in a language is writing code for that works for super-entities, and then executing this code with sub-entities. To know if the given entity type is compatible with the required entity type, we require a predicate that defines this compatibility. We have created such a predicate while implementing general type compatibility in subsection \emph{TO-DO}, in the form of \lstinline|typeCompatibleB : TYPE * TYPE -> BOOL|.

      With the addition of entity inheritance, we need to expand this definition. To this end, we added the rules as shown in listing \emph{TO-DO}. Given two entity scopes, the \lstinline|inherits(s_sub, s_super)| predicate returns true when the query has one result. The query in the \texttt{inherits} rule requests all paths from scope \texttt{s\_sub} to scope \texttt{s\_super} consisting of only \texttt{INHERIT} edges. Such a path exists if and only if the entity belonging to scope \texttt{s\_sub} inherits the entity belonging to \texttt{s\_super}.

      \begin{minted}[firstline=3]{\statix}
  module x
  rules
    typeCompatibleB(ENTITY(s_sub), ENTITY(s_super)) = inherits(s_sub, s_super).

    inherits : scope * scope -> BOOL
    inherits(s_sub, s_super) = nonEmptyPathScopeList(ps) :-
      query () filter INHERIT*
                and { s :- s == s_super }
                min $ < INHERIT
                in s_sub |-> ps.

    nonEmptyPathScopeList : list((path * scope)) -> BOOL
    nonEmptyPathScopeList(_)       = FALSE().
    nonEmptyPathScopeList([(_,_)]) = TRUE().
      \end{minted}

  \section{\label{sec:entity-extension}Entity Extension}

    \subsection{\label{subsec:type-extension}Built-in Type Extension}

  \section{\label{sec:function-template-overloading}Function and Template Overloading}

  \section{\label{sec:module-system}Module system}

  \section{\label{sec:built-in-library}Pre-analyzed built-in library}

  \section{\label{sec:statix-reflection}Reflection on Statix}

    \begin{itemize}
      \item Repeat reasons for using Statix
      \item What worked out as intended?
      \item What did not work as intended?
      \item What are the workarounds?
      \item Recommendations for improving Statix
    \end{itemize}
