% !TEX root = document.tex

\chapter{\label{chap:statix}WebDSL in Statix}

  In this chapter, we elaborate on the implementation of the WebDSL static semantics in Statix, using the examples from \cref{chap:webdsl} as a basis. We start this chapter by introducing the meta-DSL Statix. Once the goal and basics of Statix are stated, we describe the implementation of the type system that is the core of WebDSL. Next, we address and discuss the challenges faced while implementing non-trivial WebDSL features in Statix and lastly we reflect on the developer experience of using Statix to implement static analyses.

  \section{\label{sec:statix}Introduction to Statix}

    Statix is a constraint-based declarative language for the specification of type systems, introduced in 2018 \autocite{VanAntwerpen2018}. Since then, the meta-DSL Statix has become a part of the Spoofax Language Workbench and allows language developers to implement static analyses to provide language-specific feedback to developers on written code.

    A Statix specification consists of rules over terms that define constraints. Additionally, Statix rules build and query a \textit{scope graph} \autocite{Neron2015} that provides a language-agnostic representation of a program. A scope graph consists of nodes and edges that can be used to for example model the lexical scope of variables.

    \subsection{Language Signature}

      \begin{wrapfigure}{r}{0.58\linewidth}
        \vspace{-15pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    sorts
      Application
      Exp
    
    constructors
      Application : Exp       -> Application
      True        :              Exp
      False       :              Exp
      Int         : string    -> Exp
      Add         : Exp * Exp -> Exp
        \end{minted}
        \caption{\label{fig:statix-signatures}Language signature in Statix}
        \vspace{-10pt}
      \end{wrapfigure}

      Consider a language consisting of booleans, integers and addition, for which we want to create a type-checker with Statix. First, Statix requires us to declare all types and sorts that we will be using in the rules. These Statix constructor names have to match the constructors of the input term (the AST). The Statix code that declares the sorts and constructors of our example language is shown in \cref{fig:statix-signatures}. When writing a Statix specification for a language implemented in the Spoofax language workbench, it is a common practice to have the Statix signature generated from your SDF3 specification by the Statix signature generator (see \cref{subsec:statix-signature-generator}), to prevent code duplication.

      So far, our specification consists of two sorts. The \texttt{Application} sort defines the entry point of our language, it has one constructor with an identical name. Next, the sort \texttt{Exp} describes what expressions are allowed. It has four constructors: the Boolean values \texttt{True} and \texttt{False}, \texttt{Int} which requires an integer literal as subterm, and \texttt{Add} which takes two nested expressions as subterms. Examples of valid input according to our defined signature are shown in \cref{fig:statix-valid-input}.

      \begin{figure}[H]
        \begin{minted}[frame=single]{javascript}
  Application(True())                    // true
  Application(Int("42"))                 // 42
  Application(Add(Int("40"), Int("2")))  // 40 + 2
  Application(Add(Int("40"), False()))   // 40 + false
        \end{minted}
        \caption{\label{fig:statix-valid-input}Valid input terms for the described language}
      \end{figure}

    \subsection{Semantic Types}

      Not all of the valid input terms according to our signature are well-typed. For example, the last term shown in \cref{fig:statix-valid-input} features an addition of the integer literal \texttt{40} and the Boolean value \texttt{False}. Using Statix' constraint solving capabilities, we would like to give feedback to the programmer that the input is ill-typed.

      Given the code in \cref{fig:statix-signatures}, our Statix specification does not yet generate any constraints. Constraints that we would like to generate using Statix rules are firstly that a program must be well-typed and secondly, in order for an addition expression to be well-typed, its two subterms must be of integer type.

      \begin{wrapfigure}{r}{0.5\linewidth}
        \vspace{-20pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    sorts
      TYPE
    
    constructors
      BOOL : TYPE
      INT  : TYPE
        \end{minted}
        \caption{\label{fig:statix-type-signatures}Statix signature for Boolean and integer types}
        \vspace{-40pt}
      \end{wrapfigure}

      To reason about the types of expressions and use them in constraints, we must first define them in our specification, as shown in \cref{fig:statix-type-signatures}. To distinguish input sorts and constructors from semantic types that we will use in our constraints, those sorts and constructors are defined in upper-case. With the new \texttt{TYPE} sort that has two constructors: \texttt{BOOL} and \texttt{INT}, we can start generating constraints on input terms.

    \subsection{Predicates and Rules}

      \Cref{fig:statix-basic-rules} lists the Statix predicates and rules required to generate the constraints we want to be satisfied in order for a program to be well-typed. 

      \begin{figure}[H]
        \begin{minted}[]{\statix}
  module x
  rules

    applicationOk : Application
    applicationOk(Application(e)) :- { T }
      typeOfExp(e) == T.

    typeOfExp : Exp -> TYPE
    typeOfExp(True()) = BOOL().
    typeOfExp(False()) = BOOL().
    typeOfExp(Int(_)) = INT().
    typeOfExp(Add(e1, e2)) = INT() :-
      typeOfExp(e1) == INT(),
      typeOfExp(e2) == INT().
        \end{minted}
        \caption{\label{fig:statix-basic-rules}Statix predicates and rules for typing booleans, integers and addition}
      \end{figure}

      The type of all Statix predicates must be explicitly declared, for example the \texttt{applicationOk} predicate on \textbf{line 3} specifies that all rules of \texttt{applicationOk} match exactly one constructor \texttt{Application}. An instantiation of the \texttt{applicationOk} predicate is on \textbf{line 4}. In prose English it would read ``An application is well-typed, given that for some type \texttt{T}, the expression \texttt{e} has type \texttt{T}''.
      
      The other Statix rule in our small example specification is a \textit{functional predicate}, meaning that it returns a value. All but the last rules of the \texttt{typeOfExp} predicate compute a \texttt{TYPE} for a given expression, without conditions. The last rule of the example does have two conditions, in prose English it would read ``\texttt{e1} plus \texttt{e2} is of type \texttt{INT}, given that \texttt{e1} is of type \texttt{INT} and \texttt{e2} is of type \texttt{INT}''.

    \subsection{\label{subsec:building-and-querying-scope-graphs}Building and Querying Scope Graphs}

      When we expand our small example language with let-bindings and we want to add typing rules for this new construct, we come across a new feature in Statix. To facilitate typing rules for name binding, Statix uses \textit{scope graphs} \autocite{Neron2015}. Scope graphs are built out of three components: scopes, edges and declarations.

      \begin{figure}[h]
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope] at(-1, 0) {s1};
            \node (x_1) [decl]  at(1, 0) {x};

            \draw[decl edge] (s_1.east) -- (x_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example1}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (x_1) [decl]  at(1, 0) {x};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_1.east) -- (x_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example2}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (x_1) [decl]  at(1, 0) {x};
            \node (y_1) [decl]  at(1, -1.5) {y};
            \node (z_1) [decl]  at(1, -2.5) {z};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_1.east) -- (x_1.west);
            \draw[decl edge] (s_2.east) -- (y_1.west);
            \draw[decl edge] (s_2.east) -- (z_1.west);
          \end{tikzpicture}
          \caption{\label{fig:scope-graph-example3}}
        \end{subfigure}
        \caption{\label{fig:scope-graph-examples}Scope graph examples}
      \end{figure}

      \Cref{fig:scope-graph-examples} showcases three examples of scope graphs. \Cref{fig:scope-graph-example1} consists of a single scope \texttt{s1} with declaration \texttt{x} that could be a model of a module with a single global variable \texttt{x} declared inside. The second example, \cref{fig:scope-graph-example2}, consists of two scopes: a root scope \texttt{s1} with again a declaration of \texttt{x}, and a scope \texttt{s2} with an outgoing edge to \texttt{s1} labeled \texttt{P}. The \texttt{P} label is often used to denote the relation of a lexical parent scope. In this example, \texttt{s2} could for example model an empty function declared in module \texttt{s1}. The last example again has two scopes, with one declaration in \texttt{s1} and two declarations in \texttt{s2}. This could model the same program as described previously, but now with two local variable declarations inside the function body of \texttt{s2}.

      \begin{wrapfigure}{r}{0.5\linewidth}
        \vspace{-20pt}
        \capstart
        \begin{minted}[]{\statix}
  module x
  signature
    constructors
      Let : string * Exp * Exp -> Exp
      Var : string             -> Exp

    name-resolution
      labels
        P // to denote parent scope

    relations
      var : string * TYPE
        \end{minted}
        \caption{\label{fig:statix-let-binding-signatures}Statix signature for let-bindings}
        % \vspace{-40pt}
      \end{wrapfigure}

      The first step in implementing let-bindings in Statix is adding the signature. In addition to the new constructors on \textbf{line 3 and 4}, we now introduce an edge label \texttt{P} and the relation \texttt{var}. The edge labels defined in the constructor provide the set of allowed labels to use in rules later on. The relation \texttt{var} on \textbf{line 11} specifies that any declaration made under the \texttt{var} relation in a scope, maps an identifier to its type.
      
      For illustration purposes, when we want to encode a single scope with two variable declarations, \texttt{x} of type \texttt{INT} and \texttt{b} of type \texttt{BOOL}, its scope graph would be as shown in \cref{fig:scope-graph-relations-example}.

      \begin{figure}[h]
        \centering
        \begin{tikzpicture}
          \node (s_1) [scope]   at(0, 0) {s1};
          \node (x_1) [decl]  at(3, 0.5) {x : INT()};
          \node (b_1) [decl]  at(3, -0.5) {b : BOOL()};

          \draw[decl edge] (s_1.east) -- (x_1.west) node[midway, sloped, fill=white] {var};
          \draw[decl edge] (s_1.east) -- (b_1.west) node[midway, sloped, fill=white] {var};
        \end{tikzpicture}
        \caption{\label{fig:scope-graph-relations-example}A scope graph containing a single scope with two declared variables}
      \end{figure}

      In Statix, scopes can be passed around as data. When we are evaluating an expression in our extended language, we now also want to pass the current scope. If the current input term that we are generating constraints for is a let-binding, we want to create a new scope, link it to the previous one, declare the variable in the new scope and evaluate the expression. To generate constraints for a variable expression, we want to query the scope graph and get its type. The Statix rules to reflect this are shown in \cref{fig:statix-let-binding-rules}.

      \begin{figure}[h]
        \begin{minted}[]{\statix}
  module x
  rules
    applicationOk : Application
    applicationOk(Application(e)) :- { s T }
      new s,
      typeOfExp(s, e) == T.

    typeOfExp : scope * Exp -> TYPE
    // ... previous rules
    typeOfExp(s, Let(x, e1, e2)) = T2 :- { s_let T1 }
      typeOfExp(s, e1) == T1,
      new s_let,
      s_let -P-> s,
      !var[x, T1] in s_let,
      T2 == typeOfExp(s_let, e2).

    typeOfExp(s, Var(x)) = T :-
      query var filter P*
                and { x' :- (x', _) == (x, _) }
                min $ < P
                and true
                in s |-> [(_, (_, T))].
        \end{minted}
        \caption{\label{fig:statix-let-binding-rules}Statix rules for let-bindings}
      \end{figure}

      \Cref{fig:statix-let-binding-rules} showcases various previously unexplained constructs:
      \begin{itemize}
        \item \textbf{Line 4} creates a new scope \texttt{s}. This scope is the root scope since it is created once at the start of an application and is not linked to any other scope.
        \item \textbf{Line 7} shows the new signature of the \texttt{typeOfExp} functional predicate. Given a scope and an expression, the rules of \texttt{typeOfExp} will compute the type of the expression.
        \item \textbf{Line 9-14} gives the typing rule of a let-binding. Given that the let-binding is of form \texttt{let x = e1 in e2}, the rule:
        \begin{itemize}
          \item computes the type of \texttt{e1} on line 10;
          \item creates a new scope \texttt{s\_let} on line 11 for the body of the let to evaluate in;
          \item declares variable \texttt{x} with associated type \texttt{T1} in the newly created scope \texttt{s\_let};
          \item computes the type of \texttt{e2} and this is the result of the rule.
        \end{itemize}
        \item \textbf{Line 16-21} holds the implementation of the variable typing rule. It executes a query with the following properties:
        \begin{itemize}
          \item It only returns entries in the \texttt{var} relation (line 17)
          \item It may follow zero or more \texttt{P} edge labels to other scopes (line 17);
          \item It only returns declarations under the same identifier as \texttt{x} (line 18);
          \item It prefers local declarations over declarations for which P edges must be followed (line 19);
          \item Shadowing according to the shadowing rules of line 19 is enabled (line 20);
          \item The query starts in the passed scope \texttt{s} (line 21);
          \item The result may only be one declaration (line 21).
        \end{itemize}
      \end{itemize}

      \Cref{fig:statix-let-binding-example} shows a possible input and the constructed scope graph after the constraints have been solved.

      \begin{figure}[h]
        \begin{subfigure}[b]{0.33\textwidth}
          \begin{minted}{javascript}
    let x = 1 in
      let y = x in
        x + y
          \end{minted}
          \caption{\label{fig:statix-let-binding-example-input}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \begin{minted}{javascript}
  Application(
    Let(
      "x", Int("1"), Let(
        "y", Var("x"), Add(
          Var("x"),
          Var("y")
        )
      )
    )
  )
          \end{minted}
          \caption{\label{fig:statix-let-binding-example-term}}
        \end{subfigure}
        \begin{subfigure}[b]{0.33\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (s_3) [scope]   at(-1, -4) {s2};
            \node (x_1) [decl]  at(2, -2) {x};
            \node (y_1) [decl]  at(2, -4) {y};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[scope edge] (s_3.north) -- (s_2.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_2.east) -- (x_1.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_3.east) -- (y_1.west) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:statix-let-binding-example-sg}}
        \end{subfigure}
        \caption{\label{fig:statix-let-binding-example}Constructed scope graph after the example specification solved its contraints}
      \end{figure}

  \section{\label{sec:simple-type-systems}Encoding the WebDSL Basics}

  \begin{wrapfigure}{r}{0.5\linewidth}
    \vspace{-20pt}
    \capstart
    \begin{minted}[]{\statix}
  module x
  rules
    projectOk : scope
    unitOk    : scope * Unit
    sectionOk : scope * Section
    defOk     : scope * Definition
    typeOfExp : scope * Exp -> TYPE
    \end{minted}
    \caption{\label{fig:webdsl-basic-predicates}Predicates that form the basis of the WebDSL Statix specification}
    \vspace{-10pt}
  \end{wrapfigure}

      The WebDSL language adheres to a structure similar to many popular programming languages. A WebDSL application consists of multiple files. At the topmost level in a file, there is a module or \textit{unit} declaration. Within a module, multiple \textit{sections} of \textit{definitions} exist, such as pages, templates, entities and functions. A function consists of consecutive \textit{statements} such as variable assignment (\texttt{var n := 2}). At the innermost level, these statements contain \textit{expressions} that form the basis the WebDSL type system.

      To define well-typedness of the mentioned constructs, the Statix predicates as shown in \cref{fig:webdsl-basic-predicates} form the backbone of the WebDSL Statix specification.

    \subsection{\label{subsec:built-in-types-and-constants}Built-in Types and Constant Expressions}

      Constant expressions such as strings, integers and booleans form the building blocks of more complication constructs. For reasons explained later (see \cref{sec:type-extension}), a built-in type such as string is not declared as \texttt{STRING : TYPE} but instead as \texttt{BUILTINTYPE : scope * string -> TYPE}, where the instantiation of the string type is as follows: \texttt{BUILTINTYPE(s, "String")}.

      These built-in types are declared in a scope that is reachable from almost every location, the project scope, once per analysis. All WebDSL type declarations are made under the \texttt{type} relation, which associates the human readable type name with a \texttt{TYPE} term: \texttt{type : string * TYPE}. The part of the Statix specification to achieve this, and the resulting scope graph are shown in \cref{fig:webdsl-basics-built-in-types-decl}.

      \begin{figure}[h]
        \begin{subfigure}[b]{0.5\textwidth}
          \begin{minted}[firstline=3]{\statix}
module x
rules
  projectOk(s_project) :- 
    declareTypeBuiltIns(s_project).
    // ...

  declareTypeBuiltIns : scope
  declareTypeBuiltIns(s) :-
    declareType(s, "Int", 
      BUILTINTYPE(new, "Int")).
    // ...

  declareType : scope * string * TYPE
  declareType(s, name, t) :-
    !type[name, t] in s.
          \end{minted}
          \vspace{-10pt}
          \caption{\label{fig:webdsl-basics-built-in-types-decl-stx}}
        \end{subfigure}
        \begin{subfigure}[b]{0.5\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope] at(0, 0) {s\_project};
            \node (t_1) [decl] at(0, -3) {Int : BUILTINTYPE(s\_int, "Int")};

            \draw[decl edge] (s_1.south) -- (t_1.north) node[midway, sloped, fill=white] {type};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-basics-built-in-types-decl-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-basics-built-in-types-decl}Declaring built-in types in the project scope}
      \end{figure}

      \begin{wrapfigure}{r}{0.57\textwidth}
        \capstart
        \begin{minted}[firstline=3]{\statix}
module x
rules
  typeOfExp(s, Const(Int(_))) = t :-
    resolveType(s, "Int") == [(_, (_, t))].

  resolveType : scope * string
    -> list((path * (string * TYPE)))
  resolveType(s, name) = ts :-
    query type filter P*
               and { t' :- t' == (name, _) }
               in s |-> ts.
        \end{minted}
        \caption{\label{fig:webdsl-basics-built-in-types-query}WebDSL integer constant expression typing rules}
      \end{wrapfigure}

      To retrieve a built-in type when evaluating a constant expression, we need to query the scope graph and resolve the type associated with the string representation. For example, the typing rules of an integer constant are listed in \cref{fig:webdsl-basics-built-in-types-query}. The integer typing rule introduces a constraint that the scope graph must contain a single type declaration associated with \texttt{"Int"} under the \texttt{type} relation. The result of the \texttt{resolveType} functional predicate on \textbf{line 2} should be a list containing one entry, namely the pair that we declared in \cref{fig:webdsl-basics-built-in-types-decl}. Other WebDSL constant expressions such as booleans, longs and floats have similar typing rules.

      \begin{wrapfigure}{r}{0.4\textwidth}
        \capstart
        \begin{minted}[frame=single, linenos, numbersep=-11pt]{javascript}
  "Hello world" // value
  "Hello ~( 1 + 2 )" // exp
  "Hello ~x.y" // simple exp
        \end{minted}
        \caption{\label{fig:statix-webdsl-string-interpolation-example}WebDSL string interpolation examples}
      \end{wrapfigure}

      The typing of perhaps the most common constant expression, a string, has an additional condition to be well-typed. Because string interpolation is possible, the constructor of a WebDSL string contains multiple parts that may impose additional constraints. A demonstration of the different interpolated parts is shown in \cref{fig:statix-webdsl-string-interpolation-example} and the complete typing rules are shown in \cref{fig:webdsl-basics-built-in-types-string}. The parts can be a simple string value which imposes no additional constraints, they can be a complete interpolated expression which requires the expression to be typed, or lastly they can be a ``simple'' expression which is directly inlineable.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  typeOfExp(s, Const(StringConst(String(str)))) = t :-
    resolveType(s, "String") == [(_, (_, t))],
    stringPartsOk(s, str).

  stringPartsOk maps stringPartOk(*, list(*))
  stringPartOk : scope * StringPart
  stringPartOk(s, StringValue(_)).
  stringPartOk(s, InterpExp(exp)) :- typed(s, exp).
  stringPartOk(s, InterpValue(InterpSimpleExp(simple_exp))) :- { T }
    typeOfSimpleExp(s, simple_exp) == T.
        \end{minted}
        \caption{\label{fig:webdsl-basics-built-in-types-string}WebDSL string typing rules}
      \end{figure}

      Now that all the typing rules for constants are implemented, typing rules for unary and binary operators are a step towards more complicated expressions. While it might seem trivial, we might require additional construct functional predicates for determining type compatibility or determining the resulting type of an expression.

    \subsection{\label{subsec:simple-variables}Variables}

      Similar to other imperative languages, WebDSL allows the use of variables to store values. These variables can be defined on multiple levels, such as in the module, within a function or at the top of a page/template definition. Additionally, functions may be embedded in entities, allowing direct access to entity properties as variables without having to prefix it with the \texttt{this} keyword.

      The basic variable declaration and resolving rules are shown in \cref{fig:webdsl-simple-variable-declaration-and-resolving}. Given a scope \texttt{s}, the declaration rule will make a declaration in \texttt{s} of variable \texttt{x} with associated type \texttt{t}.

      \begin{figure}[H]
        \begin{minted}[firstline=3]{\statix}
module x
rules
  declareVar : scope * string * TYPE
  declareVar(s, x, t) :-
    !var[x, t] in s,
    noDuplicateVarDefs(s, x)
      | error $[A variable named [x] already exists in this scope].

  resolveVar : scope * string -> list((path * (string * TYPE)))
  resolveVar(s, x) = ps :-
    query var filter P* /* The filter will be expanded throughout the chapter */
              and { x' :- x' == (x, _) }
              min $ < P
              and true
              in s |-> ps.
        \end{minted}
        \caption{\label{fig:webdsl-simple-variable-declaration-and-resolving}WebDSL variable declaration and resolving}
      \end{figure}

      \begin{wrapfigure}{r}{0.5\textwidth}
        \capstart
        \includegraphics{../img/webdsl-simple-variable-declare-before-use}
        \caption{\label{fig:webdsl-simple-variable-declare-before-use}WebDSL requires declare-before-use of variables}
      \end{wrapfigure}

      The implementation of variable typing is similar to the example of let-bindings in \cref{subsec:building-and-querying-scope-graphs}. One difference between the let-bindings and WebDSL variables is that the introduction of consecutive statements in WebDSL requires a structure that defines declare-before-use semantics, to prevent backwards- or self-references such as shown in \cref{fig:webdsl-simple-variable-declare-before-use}.

      \Cref{fig:webdsl-simple-variable-declaration-scope} shows how the scope graph is constructed when there are consecutive statements. To catch declare-before-use related errors, a new scope is created for each statement (\textbf{line 6 and 7}). When constraints are generated for a constraint (such as on \textbf{line 11}), it has access to two scopes. Scope \texttt{s} denotes the scope of the current statement. Any scope graph queries will be executed in this scope. Example: the type of this statement is queried starting in scope \texttt{s} on \textbf{line 12}). Scope \texttt{s\_decl} denotes the scope of the next statement. Any scope graph declarations will be made this scope. Example: a variable declaration is being made in scope \texttt{s\_decl} on \textbf{line 14}).

      Using this tactic, a statement can never access declarations made by itself or by the next statements, it can only access declarations from previous statements.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  stmtOk : scope * scope * Statement

  stmtsOk : scope * list(Statement)
  stmtsOk(_, []).
  stmtsOk(s, [stmt | tail]) :- {s_decl s_next}
    new s_decl, s_decl -P-> s,
    new s_next, s_next -P-> s_decl,
    stmtOk(s, s_decl, stmt),
    stmtsOk(s_next, tail).

  stmtOk(s, s_decl, VarDecl(x, sort)) :- { t }
    t == typeOfSort(s, sort),
    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort,
    declareVar(s_decl, x, t),
    @x.type := t.  
        \end{minted}
        \caption{\label{fig:webdsl-simple-variable-declaration-scope}WebDSL statements use different scopes for querying and declaring data from the scope graph}
      \end{figure}

      An example of how this structure influences the building of scope graphs, a visualization of a function, accompanied by the scope graph of its body is shown in \cref{fig:webdsl-basics-declaration-scope-example}.

      \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
          \begin{minted}[firstline=2]{\webdsl}
application test
  function f() : Int {
    var x := 1;
    var y := 2;
    return y;
  }
          \end{minted}
          \caption{\label{fig:webdsl-basics-declaration-scope-example-code}}
        \end{subfigure}
        \begin{subfigure}[b]{0.7\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_1) [scope]   at(-1, 0) {s1};
            \node (s_2) [scope]   at(-1, -2) {s2};
            \node (s_3) [scope]   at(-1, -4) {s2};
            \node (x_1) [decl]  at(4, -2) {x : BUILTINTYPE(s\_int, "Int")};
            \node (y_1) [decl]  at(4, -4) {y : BUILTINTYPE(s\_int, "Int")};
  
            \draw[scope edge] (s_2.north) -- (s_1.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[scope edge] (s_3.north) -- (s_2.south) node[pos=0.5, xshift=-1ex] {P};
            \draw[decl edge] (s_2.east) -- (x_1.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_3.east) -- (y_1.west) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-basics-declaration-scope-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-basics-declaration-scope-example}Variable declarations example using a separate declaration scopes}
      \end{figure}

      Another difference between the let-binding rules from an earlier example and WebDSL variables is the complexity of the shadowing rules. The WebDSL variable shadowing rules which we reverse-engineered from the current compiler and static analysis implementation, state that the same variable identifier may be used multiple times, but never twice in the ``environment''. Such environments are: module scope, entity properties, functions, templates, etc. If a variable reference has multiple declarations in reach, the closest one according to the shadowing rules will be picked. The regular expression that defines the reachability of variables (left out in \textbf{line 9} of \cref{fig:webdsl-simple-variable-declaration-and-resolving}) is shown in \cref{fig:webdsl-simple-variable-well-formedness}.

      \begin{wrapfigure}{r}{0.5\textwidth}
        \begin{minted}[frame=single]{text}
    P*
    F*
    (
        (EXTEND? (INHERIT EXTEND?)*)
      | (DEF? (IMPORT | IMPORTLIB)?)
    )
        \end{minted}
        \caption{\label{fig:webdsl-simple-variable-well-formedness}Well-formedness predicate for variable paths}
      \end{wrapfigure}

      The edge label \texttt{P} as introduced in \cref{fig:webdsl-simple-variable-declaration-scope} is the edge label used for linking consecutive statements together. The other edge labels such as complicate this regular expression, and will be will be explained in more details in later sections when their use is discussed.

      \Cref{fig:webdsl-simple-variable-well-formedness} defines what data is reachable from any point in the scope graph, but we also want some restrictions of declarations. The same environment such as function body or an entity definition may never declare the same variable twice. To achieve this, \textbf{line 4} of \cref{fig:webdsl-simple-variable-declaration-and-resolving} uses the helper predicate \texttt{noDuplicateVarDefs}. The implementation of this predicate is straight-forward and shown in \cref{fig:webdsl-simple-variable-no-duplicates}. The predicate queries the current scope and checks whether all scopes reachable using only \texttt{P} edge labels, results in a list containing only one entry.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  noDuplicateVarDefs : scope * string
  noDuplicateVarDefs(s, x) :-
    query var filter P*
              and { x' :- x' == (x, _) }
              in s |-> [_].
        \end{minted}
        \caption{\label{fig:webdsl-simple-variable-no-duplicates}The same variable identifier may only be declared once in an environment}
      \end{figure}

    \subsection{\label{subsec:type-compatibility}Type Compatibility}

      WebDSL has a notion of type compatiblity. For example, the WebDSL superclass of all entities is conveniently called \texttt{Entity}. When assigning a value to a variable that requires type \texttt{Entity}, passing an instance of a user-defined entity such as \texttt{Person} or \texttt{Project} also suffices. In this case, type \texttt{Person} is compatible with type \texttt{Entity}, but not the other way around. Type compatibility is not limited to entities. For instance, all WebDSL date types (\texttt{Date}, \texttt{Time}, \texttt{DateTime}) are compatible with each other. As a last example, null is compatible with many types. The examples given above are shown in \cref{fig:webdsl-basics-type-compatibility-example}.

      \begin{figure}
        \begin{minted}[firstline=2]{\webdsl}
application test
entity Person {}

function f() {
  var e : Entity := Person{}; // all user-defined entities are compatible with Entity
  var d : Date := now(); // now() produces a value of type DateTime
  var p : Person := null; // null is compatible with many types
}
        \end{minted}
        \caption{\label{fig:webdsl-basics-type-compatibility-example}Examples of type compatibility in WebDSL}
      \end{figure}

      To encode the type compatibility as shown in \cref{fig:webdsl-basics-type-compatibility-example} in Statix, we need a predicate that tells us, given two types \textit{A} and \textit{B}, if type \textit{A} is compatible with with \textit{B}. The signature and its general rules are shown in \cref{fig:type-compatibility-statix-basic}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
          module x
          rules
  typeCompatible : TYPE * TYPE
  // By default, two types are not compatible
  typeCompatible(T1, T2).
  // Same type is always compatible
  typeCompatible(T, T).
        \end{minted}
        \caption{\label{fig:type-compatibility-statix-basic}WebDSL type compatibility predicate and general rules}
      \end{figure}

      With only the basic rules from \cref{fig:type-compatibility-statix-basic}, we have created the equality (\texttt{==}) from Statix in predicate form. The advantage of listing it like this, is that we can now add rules to make it fit the WebDSL type system. To continue the example of \texttt{null} being compatible with every type, we can add the rules shown in \cref{fig:null-type-compatibility} to achieve this. An example of how to use our new \texttt{typeCompatible} predicate is also given on \textbf{line 8} of \cref{fig:null-type-compatibility}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
          module x
          rules
  typeOfExp(_, Null()) = NULL().
  typeCompatible(NULL(), _).

  // example of usage:
  stmtOk(s, VarDeclInit(x, sort, exp), _) :- { sortType expType }
    sortType == typeOfSort(s, sort),
    expType == typeOfExp(s, exp),
    typeCompatible(expType, sortType)
      | error $[Expression [exp] is not of type [sort], got type [expType]] @exp,
    declareVar(s, x, sort),
    @x.type := t.
        \end{minted}
        \caption{\label{fig:null-type-compatibility}Compatibility of the null expression encoded in Statix}
      \end{figure}

      \subsubsection{Typing of the addition expression}

        The typing rules for most binary operations such as conjunction is trivial: the resulting value is of boolean type, with the constraint that both operators must be of boolean type. However, the range of values in WebDSL is greater than only natural numbers and booleans. WebDSL supports other numeric types such as \texttt{Float}s and \texttt{Long}s, as well as string types and multiple subtypes of strings such as \texttt{Secret}, \texttt{Text} and \texttt{WikiText}. The addition operator supports most of these values, and the typing of this operator is not as trivial as boolean conjunction. For example: the addition of two strings results in a string, the addition of a string and an integer results in a string value and the addition of a boolean and a string is not supported.

        To calculate the return type of addition, we introduce a functional rule that calculates the least-upper-bound of two types: \texttt{lubForAdd : TYPE * TYPE -> TYPE}. The implementation of this rule is given in \cref{fig:least-upper-bound-for-addition}. The functional rule \texttt{lubForAddNumeric} is reused in other contexts, in particular when generating the constraints for comparison with operators such as greater-than, to check if two types are comparable.

        \begin{figure}
          \begin{minted}[firstline=3]{\statix}
module m
rules
  lubForAdd : TYPE * TYPE -> TYPE
  lubForAdd(T1, T2) = lubForAddNumeric(T1, T2).
  lubForAdd(t@BUILTINTYPE("String", _), _) = t.
  lubForAdd(_, t@BUILTINTYPE("String", _)) = t.

  lubForAddNumeric : TYPE * TYPE -> TYPE
  lubForAddNumeric(_, _) = UNTYPED().
  lubForAddNumeric(t@BUILTINTYPE("Int", _)    , t) = t.
  lubForAddNumeric(t@BUILTINTYPE("Long", _)   , t) = t.
  lubForAddNumeric(t@BUILTINTYPE("Float", _)  , t) = t.
  lubForAddNumeric(t@NATIVECLASS("Double", _) , t) = t.

  // implicit widening from int to long
  lubForAddNumeric(BUILTINTYPE("Int", _)      , t@BUILTINTYPE("Long", _))   = t.
  lubForAddNumeric(t@BUILTINTYPE("Long", _)   , BUILTINTYPE("Int", _))      = t.

  // implicit widening from float to double
  lubForAddNumeric(t@NATIVECLASS("Double", _) , BUILTINTYPE("Float", _))    = t.
  lubForAddNumeric(BUILTINTYPE("Float", _)    , t@NATIVECLASS("Double", _)) = t.
          \end{minted}
          \caption{\label{fig:least-upper-bound-for-addition}Least-upper-bound rules for addition}
        \end{figure}

    \subsection{\label{subsec:boolean-logic}Boolean Logic in Statix}

      So far, most of the WebDSL's static semantics are expressible in Statix. However, the elegance of the Statix definition is sometimes lost due to code duplication. For example, logical negation and disjunction of predicates are not natively expressible in Statix, and require boilerplate code to function. To tackle this challenge, we introduced a notion of explicit boolean results for predicates that are reusable. The implementation in Statix is shown in \cref{fig:boolean-computation-results-in-statix}. The figure shows a predicate from before (\texttt{typeCompatible : TYPE * TYPE}) now changed to return an explicit result: \texttt{typeCompatibleB : TYPE * TYPE -> BOOL}. Additionally, we scope this boolean result in a predicate \texttt{typeCompatible(T1, T2) :- typeCompatibleB(T1, T2) == TRUE().} such that existing references can be left unchanged.

      \begin{figure}
        \begin{minted}[firstline=2]{\statix}
module m
  signature
    sorts
      BOOL   // used as return values of functional rules

  constructors
    TRUE : BOOL
    FALSE : BOOL

  rules
    // return a TRUE() or FALSE() value instead of failing/passing constraint
    typeCompatibleB : TYPE * TYPE -> BOOL

    // scope this explicit results in a predicate to avoid having to work 
    // with boolean computation everywhere
    typeCompatible : TYPE * TYPE
    typeCompatible(T1, T2) :- typeCompatibleB(T1, T2) == TRUE().
        \end{minted}
        \caption{\label{fig:boolean-computation-results-in-statix}Boolean computation results in Statix}
      \end{figure}

      As hinted before, the explicit return values of functional rules open up new possibilities for expressing constraints. One instance of where this is necessary, is expressing the semantics of an equality check in WebDSL. For the expression \texttt{A == B} to type check, the types have to be compatible. The naive implementation would be to define the constraint \texttt{typeCompatible(T\_A, T\_B)}. However, type compatibilty is not symmetrical while the equality check should be: \texttt{A == B $\iff$ B == A}. An example of type compatibilty not being symmetrical is when dealing with entity inheritance (see \cref{subsec:inheritance}). To properly define the static semantics for the equality expression in Statix, we need the newly defined boolean computation rules. The result is shown in \cref{fig:boolean-computation-for-equality-expression}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module m
  rules
    or  : BOOL * BOOL
    orB : BOOL * BOOL -> BOOL

    or(b1, b2) :- orB(b1, b2) == TRUE().
    
    orB(_, _) = FALSE().
    orB(TRUE(), _) = TRUE().
    orB(FALSE(), TRUE()) = TRUE().

    // (e1 == e2)
    typeOfExp(s, Eq(e1, e2)) = t :- { T1 T2 }
      t == bool(s),
      typeOfExp(s, e1) == T1,
      typeOfExp(s, e2) == T2,
      or(
        typeCompatibleB(T1, T2),
        typeCompatibleB(T2, T1)
      ).
        \end{minted}
        \caption{\label{fig:boolean-computation-for-equality-expression}Using boolean computation results in Statix for the equality expression}
      \end{figure}

    \subsection{\label{subsec:simple-entities}Entities and Properties}

      Entities form the basis of the type system and data structure in a WebDSL application. Using Hibernate as an object-relational mapping (ORM) tool, instances of entities can be persisted without explicit communication with a database management system. Entities typically have multiple properties which values are persisted, and functions that can be called and will be executed in the scope of the instantiated entity. Entity properties and entity functions together form the entity body declarations.

      In the WebDSL type system, entities are declared in the scope of the module they are defined in. An entity is a type in the WebDSL type system, similar to built-in types such as \texttt{String} and \texttt{Int}. The Statix code to declare entities is shown in \cref{fig:webdsl-entity-declaration-statix} and an example of a simple program with entity definition plus its scope graph is shown in \cref{fig:webdsl-entity-example}.

      \begin{figure}
        \begin{minted}[firstline=2]{\statix}
module x
  signature
    constructors
      // an entity constructor has two subterms:
      // - the entity name
      // - the scope of the entity where all the properties and 
      //   functions are declared
      ENTITY : string * scope -> TYPE

  rules
    defOk(s_module, EntityNoSuper(entity_name, body)) :- { s_entity }
      // a new scope for the entity is created and linked to the module scope
      // using the `DEF' (for definition) edge label
      new s_entity, s_entity -DEF-> s_module,

      // the new entity is declared as type in the module scope
      declareType(s_module, entity_name, ENTITY(entity_name, s_entity)),

      // finally a helper rule is called that properly handles
      // the entity body definitions (properties, functions, etc.)
      declEntityBody(s_entity, entity_name, body).
        \end{minted}
        \caption{\label{fig:webdsl-entity-declaration-statix}The Statix rules for declaring entities}
      \end{figure}

      \begin{figure}
        \begin{subfigure}[b]{0.2\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
  module m
    entity Person { 
      // no properties
      // for now...
    }
          \end{minted}
          \caption{\label{fig:webdsl-entity-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.8\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_p) [scope]   at(-1, -2) {s\_person};
            \node (t_p) [decl]  at(4.5, 0) {Person : ENTITY("Person", s\_person)};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[pos=0.5, xshift=2ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-entity-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-entity-example}An example of entity definition in WebDSL}
      \end{figure}

      The \texttt{declareType} and \texttt{resolveType} rules as introduced in \cref{fig:webdsl-basics-built-in-types-decl} need to be updated to work as intended for resolving and declaring entities. To prevent duplicate entity definitions, the \texttt{declareType} rule is extended with one additional rule as shown in \cref{fig:webdsl-entity-new-type-declare-and-resolve}. \textbf{Line 4} was added to \texttt{declareType}, to make sure when you declare a new type or entity, its name is unique.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
  rules
    declareType : scope * string * TYPE
    declareType(s, name, t) :-
      !type[name, t] in s,
      resolveType(s, name) == [(_, (_, t))]
        | error $[Type [name] is defined multiple times] @name.

    resolveType : scope * string -> list((path * (string * TYPE)))
    resolveType(s, name) = typesOf(ts) :-
      query type filter P* DEF?   // resolving a type may
                                  // optionally follow DEF edge label
                 and { t' :- t' == (name, _) }
                 in s |-> ts.
        \end{minted}
        \caption{\label{fig:webdsl-entity-new-type-declare-and-resolve}\texttt{declareType} now shows an error when two types with the same name are declared and \texttt{resolveType} may optinally follow a \texttt{DEF} edge label}
      \end{figure}

      In addition to the added constraint to the \texttt{declareType} rule, we added an optional \texttt{DEF} edge label that may be followed when querying the scope graph for a type (\textbf{{line 9}} of \cref{fig:webdsl-entity-new-type-declare-and-resolve}). The \texttt{DEF} (short for defintion) is used to link the scope of top-level elements, such as entities and functions, to the module scope. This can be seen in \textbf{line 13} of \cref{fig:webdsl-entity-declaration-statix}.

      So far, there has been no reason to query for types inside the entity body because we have always worked with empty entities. In practice, entities are filled with properties and functions. \textbf{Line 20} of \cref{fig:webdsl-entity-declaration-statix} calls the \texttt{declEntityBody} predicate, of which the implementation is shown in \cref{fig:webdsl-entity-body-declaration} and an example of an entity definition with two properties is shown in \cref{fig:webdsl-entity-body-example}.
      
      Entity properties are declared under the variable relation inside the entity scope, such that functions inside entities can reference their own properties without using the \texttt{this} prefix. The \texttt{this} construct is supported, but not necessary. Declaring properties in this way, allows us to reuse the already existing rules such as those against duplicate definition, without duplicating the code for another relation.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
  rules
  declEntityBody maps declEntityBodyDeclaration(*, *, list(*))
  declEntityBodyDeclaration : scope * string * EntityBodyDeclaration

  // entity property
  declEntityBodyDeclaration(s, ent, 
      Property(x, propkind, sort, PropAnnos(annos))) :- { sortType }

    // resolve the type of the property
    sortType == typeOfSort(s, sort),

    // there are some restrictions on property types
    sortType != UNTYPED()
      | error $[Cannot resolve type [sort]] @sort,
    sortType != VOID()
      | error $[Property type 'Void' not allowed] @sort,
    sortType != REF(_)
      | error $[Reference type is not allowed in property] @sort,
    isValidTypeForPropKind(propkind, sort, sortType),

    // declare the property as variable in the entity scope
    declareVar(s, x, sortType),

    // use a helper predicate to check for the uniqueness of
    // the property name
    resolveLocalProperty(s, x) == [_]
      | error $[Property [x] of entity [ent] is defined multiple times] @x.
        \end{minted}
        \caption{\label{fig:webdsl-entity-body-declaration}Statix rules for declaring the entity body}
      \end{figure}

      \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
  module m
    entity Person { 
      name        : String
      dateOfBirth : Date
    }
          \end{minted}
          \caption{\label{fig:webdsl-entity-body-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.7\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_p) [scope]   at(-1, -2) {s\_person};
            \node (t_p) [decl]  at(4.5, 0) {Person : ENTITY("Person", s\_person)};
            \node (name) [decl]  at(5.5, -1.5) {name : BUILTINTYPE(s\_string, "String")};
            \node (dob) [decl]  at(5.5, -2.5) {dateOfBirth : BUILTINTYPE(s\_date, "Date")};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[pos=0.5, xshift=2ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
            \draw[decl edge] (s_p.east) -- (name.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_p.east) -- (dob.west) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-entity-body-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-entity-body-example}An example of an entity definition with multiple properties}
      \end{figure}

      When instantiating an entity, the properties declared in the entity body may be given a value in the instantiation expression. To express this in Statix, an entity instantiation first retrieves the scope of the entity. If the scope cannot be retrieved, it means that the entity is unknown at the position of the expression, so either the entity was never declared or it is not imported correctly. Secondly, all instantiated properties must be declared under the \texttt{var} relation of the entity scope. An example of the declaration and scope graph of an entity declaration is shown in \cref{fig:webdsl-entity-body-example}. A part of the Statix rules for instantiating entities is shown in \cref{fig:webdsl-entity-instantiation}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
  rules
  typeOfExp(s, ObjectCreation(x, prop_assignments)) = e :-
    definedType(s, x) == e,
    e == ENTITY(_, _),
    propAssignmentsOk(s, e, prop_assignments).

    propAssignmentsOk maps propAssignmentOk(*, *, list(*))
    propAssignmentOk : scope * TYPE * PropAssignment
    propAssignmentOk(s, ent@ENTITY(e, s_ent),
        PropAssignment(x, exp)) :- { propType expType }
      typeOfProperty(s, ent, x) == propType,
      typeOfExp(s, exp) == expType,
      typeCompatible(expType, propType).
        \end{minted}
        \caption{\label{fig:webdsl-entity-instantiation}Statix rules for instantiating an entity}
      \end{figure}

      Even though the concepts, rules and approach mentioned in this subsection are present in the Statix specification of WebDSL, we had to simplify the examples and shown Statix rules to hide the extra complexity added concepts such as inheritance, property annotations and type extension. Those concepts will be explained in detail in section \cref{sec:advanced-entity-features} and \cref{sec:type-extension}.

    \subsection{\label{subsec:simple-pages}Pages and Templates}

      The user-inferface of a WebDSL application is built out of \textit{pages} and \textit{templates}. A page defines a path that is able to be requested by the browser while a template is a reusable component that can be part of a page or nested in other templates.

      \begin{figure}
        \begin{minted}[firstline=2]{\statix}
module x
  signature
    constructors
      PAGE     : string * list(TYPE) -> TYPE
      TEMPLATE : string * list(TYPE) -> TYPE

    relations
      page     : string * TYPE
      template : string * TYPE
        \end{minted}
        \caption{\label{fig:statix-page-and-template-constructors}Statix signature for pages and templates}
      \end{figure}

      The name of a page must be unique, while a template can be defined multiple times for different argument types (\textit{overloading}), but never multiple times for the same argument types. The statix rules to implement these checks can be found in \cref{fig:webdsl-page-and-template-definition} and an example of a module with a page and a template definition is shown in \cref{fig:webdsl-page-and-template-decl}. In the latter image, the argument type of template \texttt{t} is shortened to \texttt{String}, instead of its full version \texttt{BUILTINTYPE(s\_string, "String")}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
  rules
  declarePage : scope * string * list(TYPE)
  declarePage(s, p, ts) :-
    !page[p, PAGE(p, ts)] in s,
    resolveTemplate(s, p) == []
      | error $[Multiple page/template definitions with name [p]] @p,
    resolvePage(s, p) == [_]
      | error $[Multiple page/template definitions with name [p]] @p.

  declareTemplate : scope * string * list(TYPE)
  declareTemplate(s, t, ts) :-
    !template[t, TEMPLATE(t, ts)] in s,
    resolvePage(s, t) == []
      | error $[Multiple page/template definitions with name [t]] @t,
    filterTemplateResultsArgs(resolveTemplate(s, t), ts) == [_]
      | error $[Multiple page/template definitions with name [t] and argument types [ts]] @t.
        \end{minted}
        \caption{\label{fig:webdsl-page-and-template-definition}Statix rules for declaring WebDSL pages and templates}
      \end{figure}
      
      \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m
  page p {
    "Hello "
    t("World!")
  }

  template t(s : String) {
    ~s
  }
          \end{minted}
          \caption{\label{fig:webdsl-page-and-template-decl-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.7\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_p) [scope]   at(-2, -2) {s\_p};
            \node (s_t) [scope]   at(0, -2) {s\_t};
            \node (t_p) [decl]  at(3, 0.5) {p : PAGE("p", [])};
            \node (t_t) [decl]  at(4, -0.5) {t : TEMPLATE("t", [String])};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[scope edge] (s_t.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {page};
            \draw[decl edge] (s_m.east) -- (t_t.west) node[midway, sloped, fill=white] {template};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-page-and-template-decl-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-page-and-template-decl}An example of a module with a page \texttt{p} and a template \texttt{t}}
      \end{figure}

      Type-checking a page reference is easier than the that of a template, since a page definition cannot be overloaded. In order for a page reference to be well-typed, the page must be defined exactly once, and the types of the passed arguments must be compatible with the parameter types of the page. The Statix rules that ticks those boxes is shown in \cref{fig:webdsl-page-type-checking}. The resolving of templates is similar to that of functions and will be explained later in \cref{sec:function-template-overloading}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  pageCallOk : scope * string * list(Exp)
  pageCallOk(s, p, args) :- {argTypes ts}
    pageType(s, p) == PAGE(_, ts)
      | error $[There is no page with signature [p]] @p,
    argTypes == typesOfExps(s, args),
    typesCompatible(argTypes, ts)
      | error $[Given argument types not compatible with page definition] @args.
    
  // root page is always accessible from all locations
  pageCallOk(_, "root", []).
        \end{minted}
        \caption{\label{fig:webdsl-page-type-checking}Statix rules for type-checking a page reference}
      \end{figure}

      The body of templates and pages consist of so called \textit{Template elements}. The simplest template element is simply a text to be printed on the page. Next to plain text, hyperlinks to other pages can be created using the \texttt{navigate} element. If we take \cref{fig:webdsl-page-and-template-decl} as basis, an example of a valid navigate call would be \texttt{navigate p() \{ "Go to p" \}}. To type-check this, the code from \cref{fig:webdsl-page-type-checking} can be used. Other examples of template elements are forms, nested template calls, and at the top of a template, variables can be initialized, followed by a block of computational statements that get executed when the template is being loaded.

      Apart from regular templates, WebDSL also has a notion of Ajax templates. Ajax templates can be used as building blocks of the user interface, just like regular templates. Additionally, Ajax templates also have a possibility of being replaced on a rendered page without reloading the whole page, for example to refresh the results of a poll on a page. This addition makes Ajax templates useful for more interactive and modern web applications.

      Certain action code such as the \texttt{replace} and \texttt{refresh} statements are only supposed to work on Ajax templates, and not on regular templates. To this end we need to differentiate between them in the scope graph. We have chosen the most trivial way of implementing this, namely adding an additional argument in the type constructor of a template: \texttt{TEMPLATE : string * list(TYPE) * BOOL -> TYPE}. The last boolean argument indicates whether the template is an Ajax template or not. When resolving templates we can now resolve only Ajax templates by adding a \texttt{TRUE()} to the filter statement of the query.

    \subsection{\label{subsec:simple-functions}Functions}

      In WebDSL, a function is a sequence of statements that perform some sort of computation and can return a value. The type of the return value must be stated in the function header and is part of the signature. The implementation of the declaration and resolving of functions is similar to that of templates, as explained in \cref{subsec:simple-pages}, and therefore will not be repeated here.

      An additional characteristic of functions that is similar to templates, is the use of parameters. The parameters with their corresponding types have to be declared statically. The parameters are readable from the function body, but never writable or overridable by a local variable. Additionally, the name of parameters may shadow the name of definitions outside the function such as entity properties or global definitions. To enforce these constraints, we introduce a new edge label \texttt{F} for embedding the function scope in their surrounding scope, which is either global or within an entity. Using this new edge label, the shadowing rules can be adjusted to properly check the listed semantics. The result is shown in \cref{fig:webdsl-function-parameters-and-shadowing} and an example of a WebDSL snippet with the resulting scope graph is shown in \cref{fig:webdsl-function-parameters-and-shadowing-example}. In the example, parameter \texttt{x} of function \texttt{f} shadows the globally declared \texttt{x}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  functionOk : scope * Function
  functionOk(s_outer,
      Function(name, FormalArgs(args), OptSortSome(returnSort), Block(stmts))) 
        :- { argTypes returnType s_function s_body }

    // embed the function scope with edge label F
    new s_function, s_function -F-> s_outer,

    // declare parameters in function
    argTypes == typesOfArgs(s_outer, args),
    declareParameters(s_function, zipArgTypes(args, argTypes)),

    // create the function body and generate constraints
    new s_body, s_body -P-> s_function,
    stmtsOk(s_body, stmts, returnType),

    // declare the function in the outer scope
    returnType == typeOfSort(s_outer, returnSort),
    declFunction(s_outer, name, argTypes, returnType).

  // resolve variables via P and F edges
  resolveVar(s, x) = ps :-
    query var filter P* F*
              and { x' :- x' == (x, _) }
              min $ < P, $ < F,
                         P < F
              and true
              in s |-> ps.

  // a definition is only duplicate in a line of P edges
  noDuplicateVarDefs : scope * string
  noDuplicateVarDefs(s, x) :-
    query var filter P*
              and { x' :- x' == (x, _) }
              in s |-> [_].
        \end{minted}
        \caption{\label{fig:webdsl-function-parameters-and-shadowing}Statix rules for function parameters and variable shadowing}
      \end{figure}

      \begin{figure}
        \begin{subfigure}[b]{0.4\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m
  var x : Int := 1

  function f(x : Int, y : Int) : Int
  {
    return x + y;
  }
          \end{minted}
          \caption{\label{fig:webdsl-function-parameters-and-shadowing-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.6\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_f) [scope]   at(-1, -2) {s\_f};
            \node (s_f_body) [scope]   at(-1, -4) {s\_f\_body};
            \node (t_x) [decl]  at(2.5, 0.5) {x : Int};
            \node (t_f) [decl]  at(4.5, -0.5) {f : FUNCTION("f", [Int], Int)};
            \node (t_f_x) [decl]  at(2.5, -1.5) {x : Int};
            \node (t_f_y) [decl]  at(2.5, -2.5) {y : Int};
  
            \draw[scope edge] (s_f.north) -- (s_m.south) node[midway, xshift=1ex] {F};
            \draw[scope edge] (s_f_body.north) -- (s_f.south) node[midway, xshift=1ex] {P};
            \draw[decl edge] (s_m.east) -- (t_x.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_m.east) -- (t_f.west) node[midway, sloped, fill=white] {function};
            \draw[decl edge] (s_f.east) -- (t_f_x.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_f.east) -- (t_f_y.west) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-function-parameters-and-shadowing-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-function-parameters-and-shadowing-example}An example of a function with parameters}
      \end{figure}

      Apart from globally declared functions, functions may also be part of an entity. In this case, functions can be called similar to how entity properties are referenced. Lastly, entity functions may have the \texttt{static} annotation, which is similar to static class functions in the Java programming language. Static functions may be called without having an instantiated entity.

      \textbf{Possible TO-DO:}
      \begin{itemize}
        \item List/explain interesting action code type checking
      \end{itemize}

    \subsection{\label{subsec:access-control}Access Control}

      When developing any application that will be used in practice, access control is an important part of the system. It controls which user is allowed to see what data, what actions can be executed. Generally, this is implemented through a log-in system where different user accounts are given different rights. In all popular programming languages, developing a system access control is the responsibility of the developer, either through manual coding or using frameworks and libraries. In WebDSL however, access control is embedded in the language and all pages are protected by default.

      Concretely, the developer is able to declare what entity represents a user in the system, and what data the user needs to show to log in. In the rest of the WebDSL code, the globally available security context is extended with the properties \texttt{principal} which references the logged in user, and \texttt{loggedIn} which is true if the user has logged in. If the developer has not specified what entity represents a user, the security context is available but does not have these properties. An example of WebDSL code with resulting scope graph is shown in \cref{fig:webdsl-access-control-example} and the Statix rules used to achieve this are shown in \cref{fig:webdsl-principal-statix}. In the code for extending the security context with two additional properties, the same mechanics are used as for entity and built-in type extension. An explanation can be found later in \cref{sec:type-extension}.

      \begin{figure}
        \begin{subfigure}[b]{0.4\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m
  entity User {
    username : String
    password : Secret
  }

  principal is User
    with credentials
    username, password

  page p {
    if (securityContext.loggedIn) {
      "Welcome!"
    } else {
      "Log in first!"
    }
  }
          \end{minted}
          \caption{\label{fig:webdsl-access-control-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.6\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_u) [scope]   at (-1, -2) {s\_u};
            \node (s_p) [scope]   at(0.6, -2) {s\_p};
            \node (s_sc) [scope]   at(2.2, -2) {s\_sc};
            \node (t_p) [decl]  at(3.5, 0.5) {p : PAGE("p", [])};
            \node (t_sc) [decl]  at(4.5, -0.5) {securityContext : ENTITY(..., s\_sc)};

            \node (t_pr) [decl]  at(0, -4) {principal : ENTITY("User", s\_u)};
            \node (t_li) [decl]  at(5, -4) {loggedIn : BOOL};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[scope edge] (s_u.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {page};
            \draw[decl edge] (s_m.east) -- (t_sc.west) node[midway, sloped, fill=white] {var};

            \draw[decl edge] (t_pr.north) -- (s_sc.south) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (t_li.north) -- (s_sc.south) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-access-control-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-access-control-example}An example of access control in WebDSL. The entries related to entity \texttt{User} are omitted for brevity}
      \end{figure}

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module x
rules
  principalDefOk : scope * string * list(string)
  principalDefOk(s, ent, properties) :-
    { s_ent entityName credentialTypes t }
    definedType(s, ent) == t@ENTITY(entityName, s_ent),
    principalPropertyTypes(s_ent, properties, ent) == credentialTypes,
    compatibleCredentialTypes(properties, credentialTypes),
    declSecurityContext(s, t, credentialTypes).

  compatibleCredentialTypes maps compatibleCredentialType(list(*), list(*))
  compatibleCredentialType : string * TYPE
  compatibleCredentialType(x, s) :-
    isStringCompatibleType(s).

  declSecurityContext : scope * TYPE * list(TYPE)
  declSecurityContext(s, principalType, credentialTypes) :-
    { s_extend_security_context }
    new s_extend_security_context,
    declProperty(s_extend_security_context, "securityContext"
      , "principal", principalType),
    declProperty(s_extend_security_context, "securityContext"
      , "loggedIn", bool(s)),
    declareExtendScope(s, "securityContext", s_extend_security_context),
    extendScopes(resolveExtendScope(s, "securityContext")
      , s_extend_security_context).
        \end{minted}
        \caption{\label{fig:webdsl-principal-statix}Statix rules for declaring the access control principal}
      \end{figure}

      \textbf{Possible TO-DO:}
      \begin{itemize}
        \item References to pages and templates
        \item Wildcards
        \item Pointcuts?
      \end{itemize}

  \section{\label{sec:advanced-entity-features}Advanced Entity Features}
  
    \subsection{\label{subsec:inheritance}Inheritance}

      \subsubsection{Linking the Scopes}

      The implementation of inheritance requires the scope of the sub- and super-entity to be connected such that Statix queries can resolve to declarations from the super-entity when necessary. To achieve this, we introduce an edge label \texttt{INHERIT} as shown in \cref{fig:inheritance-statix-rules}.

      \begin{figure}
        \begin{minted}[firstline=2]{\statix}
    module x
    signature
      name-resolution
        labels
          INHERIT // inherit edge label for subclasses
  
    rules
      defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity super' s_super}
        resolveEntity(s_global, super) == [(_, (super', ENTITY(_, s_super)))],
        new s_entity, s_entity -INHERIT-> s_super,
        noCircularInheritance(s_entity),
        declEntity(s_global, s_entity, x, bodydecs),
        @super.ref := super'.
        \end{minted}
        \caption{\label{fig:inheritance-statix-rules}Entity inheritance Statix rules}
      \end{figure}

      \begin{figure}
        \begin{subfigure}[b]{0.1\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
  module m
    entity Person {
      // no properties
    }

    entity Student : Person {
      // no properties
    }

          \end{minted}
          \caption{\label{fig:webdsl-entity-inheritance-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.9\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(0, 0) {s\_m};
            \node (s_p) [scope]   at(2, -3) {s\_person};
            \node (s_s) [scope]   at(-2, -3) {s\_student};
            \node (t_p) [decl]  at(3.5, 1.5) {Person : ENTITY("Person", s\_person)};
            \node (t_s) [decl]  at(-3.5, 1.5) {Person : ENTITY("Student", s\_student)};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[scope edge] (s_s.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[scope edge] (s_s.east) -- (s_p.west) node[midway, sloped, yshift=1ex] {INHERIT};
            \draw[decl edge] (s_m.north) -- (t_p.south) node[midway, sloped, fill=white] {type};
            \draw[decl edge] (s_m.north) -- (t_s.south) node[midway, sloped, fill=white] {type};
          \end{tikzpicture}
          \caption{\label{fig:webdsl-entity-inheritance-example-sg}}
        \end{subfigure}
        \caption{\label{fig:webdsl-entity-inheritance-example}An example of entity definition in WebDSL}
      \end{figure}

      First of all, the super-entity refered to in the declaration must refer to an existing entity in the scope graph. Secondly, the new scope belonging to the sub-entity \texttt{s\_entity} is linked to the scope of the super class \texttt{s\_super} via an \texttt{INHERIT} edge. Finally, some additional constraints are generated to make sure no circular inheritance exists and constraints for the entity body declarations of the sub-entity are generated.

      The variable resolving query as listed in \cref{fig:var-resolve-query-inheritance} reflects the addition of the \texttt{INHERIT} label. The addition of \texttt{INHERIT*} in the query filter makes all variables declared in ancestors reachable, but the shadowing rule as declared after the \texttt{min} keyword ensures correct shadowing behaviour, namely that local variables are preferred over variables defined in ancestors.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
    module x
    rules
      resolveVar(s, x) = ps :-
        query var filter P* F* INHERIT*
                  and { x' :- x' == (x, _) }
                  min $ < P, $ < F, $ < INHERIT,
                             P < F, P < INHERIT,
                                    F < INHERIT
                  and true
                  in s |-> ps.
        \end{minted}
        \caption{\label{fig:var-resolve-query-inheritance}The query that specifies what variables can be resolved, updated to reflect entity inheritance}
      \end{figure}

    \subsubsection{Overwriting Functions}

      Generally, defining two functions with the same name and same argument types is not allowed in WebDSL. Entity functions are an exception to this such that entity function definitions shadow global function definitions. With the introduction of inheritance there comes another exception, namely that sub-entities are allowed to override function definitions of their ancestors.

      Previously, the resolving of entity functions was done using a query that resolves within the entity scope only. With the introduction of entity inheritance, the path well-formedness over edge labels was changed such that functions from ancestors are also in scope. Changing \texttt{filter e} to \texttt{filter INHERIT*} accomplishes this. Both the previous and resulting queries are shown in \cref{fig:entity-function-resolve-old}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
  module x
  rules
    // previously (local entity scope only)
    resolveEntityFunction(s, x) = ps :-
      query function filter e
                     and { x' :- x' == (x, _) }
                     min
                     in s |-> ps.

    // new (allow resolving to ancestors)
    resolveEntityFunction(s, x) = ps :-
      query function filter INHERIT*
                     and { x' :- x' == (x, _) }
                     min /* */
                     in s |-> ps.
        \end{minted}
        \caption{\label{fig:entity-function-resolve-old}Statix rules for allowing entity function calls to resolve to definitions in their ancestors}
      \end{figure}


      This query definition is adequate when sub-entities do not override functions. When a sub-entity does define a function that is already defined in one of its ancestors, resolving the entity function gives two results while the desired outcome is only one result, namely the overridden function defined in the sub-entity. To tackle this challenge, we defined a Statix anonymous shadowing rule combined with a label order. This ensures that when two functions with the same name and argument types exist, only the most specific (i.e. the least inheritance edges) is returned. This is implemented as shown in \cref{fig:entity-function-resolve-with-overriding}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
  module x
  rules
    resolveEntityFunction(s, x) = ps :-
      query function filter INHERIT*
                     and { x' :- x' == (x, _) }
                     /* prioritize local scope over inheritance */
                     min $ < INHERIT
                     /* shadow when function name and argument types match */
                     and {
                       (f, FUNCTION(args, _, _)),
                       (f, FUNCTION(args, _, _))
                     }
                      in s |-> ps.
        \end{minted}
        \caption{\label{fig:entity-function-resolve-with-overriding}Statix rules for resolving entity functions that allow overriding}
      \end{figure}

    \subsubsection{Entity Type Compatibility}

      A perk of having the notion of inheritance in the WebDSL language, is that it allows for better abstraction and less code duplication. An example of this is a function definition, where the argument type is an entity. This function can be called with an argument of the entity type, or one of its sub-entities. To know if the given type is compatible with the required type, we require a predicate that defines this compatibility. We have created such a predicate while implementing general type compatibility in \cref{subsec:type-compatibility}, in the form of \lstinline|typeCompatibleB : TYPE * TYPE -> BOOL|.

      With the addition of entity inheritance, we need to expand this definition. To this end, we added the rules as shown in listing \cref{fig:entity-type-compatibility-inheritance}. Given two entity scopes, the \texttt{inherits(s\_sub, s\_super)} predicate returns true when the query has one result. The query in the \texttt{inherits} rule requests all paths from scope \texttt{s\_sub} to scope \texttt{s\_super} consisting of only \texttt{INHERIT} edges. Such a path exists if and only if the entity belonging to scope \texttt{s\_sub} inherits the entity belonging to \texttt{s\_super}. An example of a scope graph with entity inheritance is shown in \cref{fig:webdsl-entity-inheritance-example}.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
  module x
  rules
    typeCompatibleB(ENTITY(s_sub), ENTITY(s_super)) = inherits(s_sub, s_super).

    inherits : scope * scope -> BOOL
    inherits(s_sub, s_super) = nonEmptyPathScopeList(ps) :-
      query () filter INHERIT*
               and { s :- s == s_super }
               min $ < INHERIT
               in s_sub |-> ps.

    nonEmptyPathScopeList : list((path * scope)) -> BOOL
    nonEmptyPathScopeList(_)       = FALSE().
    nonEmptyPathScopeList([(_,_)]) = TRUE().
        \end{minted}
        \caption{\label{fig:entity-type-compatibility-inheritance}Statix rules for entity type compatibility that support inheritance}
      \end{figure}

    \subsection{Property Annotations}

      So far, the Statix specification can validate entities, their properties and their functions. Since the goal is to never manually touch the database specification, we would like to entity properties to be more expressive by for example specifiying default values, or put a constraint on the possible values of a property. WebDSL uses \textit{property annotations} for this. \Cref{fig:webdsl-properties-example} shows an WebDSL code of an entity with properties that have annotations.

      \begin{figure}
        \begin{minted}[firstline=1]{\webdsl}
module m
  entity Course {
    key : String (default="change-me")
    ects : Float (validate(ects >= 0, "ECTS may not be lower than 0"))
    teacher : Teacher (not null)
  }

  entity Teacher {
    firstname : String
    lastname : String (length = 255)
    courses : [Course] (inverse=teacher)
    
    temporaryNumber : Int (transient)
    fullname : String := getFullName()

    function getFullName() : String {
      return "~firstname + ~lastname";
    }
  }
        \end{minted}
        \caption{\label{fig:webdsl-properties-example}Examples of entity property annotations}
      \end{figure}

      Many property annotations do not influence the scope graph. An example of this is the \texttt{default = <exp>} annotation, where Statix only needs to check whether the given expression is compatible with the property type. For the \texttt{length = <exp>} annotation, the same holds, except that the expression must now have type \texttt{Int}.

      An interesting property to point out is the derived property, as shown in for property \texttt{fullname} of the \texttt{Teacher} entity in \cref{fig:webdsl-properties-example}. While this is not strictly an annotation, it does change something in the scope graph. A derived value can be calculated from other properties of the entity and does not have to be stored. It's value can also not be changed directly. The latter property is something we need to store in the scope graph, such that we can give an error when the developers attempts to assign a value directly to a derived property. For this, a new relation is introduced in Statix, which allows us to declare annotations on properties in the scope of an entity. An example of this is shown in \cref{fig:derived-annotation-example}. When assigning a variable, the left-hand side of the assignment can now be checked for mutability. The implementation of this checks whether the entity property that is referenced on the left-hand side has the \texttt{DERIVED()} annotation. To prevent code duplication, we chose to re-use the \texttt{DERIVED()} property for function parameters, which can only be referenced but never changed in the function body.

      \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m
  entity Person {
    firstname : String
    lastname  : String
    fullname  : String :=
      "~firstname + ~lastname"
  }
          \end{minted}
          \caption{\label{fig:derived-annotation-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.7\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(0, 0) {s\_m};
            \node (s_p) [scope]   at(0, -2.5) {s\_person};
            \node (t_p) [decl]  at(5.2, 0) {Person : ENTITY("Person", s\_person)};
            \node (t_fin) [decl]  at(5, -1) {firstname : String};
            \node (t_ln) [decl]  at(5, -2) {lastname : String};
            \node (t_fun) [decl]  at(5, -3) {fullname : String};
            \node (t_der) [decl]  at(5.5, -4) {fullname : DERIVED()};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
            \draw[decl edge] (s_p.east) -- (t_fin.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_p.east) -- (t_ln.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_p.east) -- (t_fun.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_p.east) -- (t_der.west) node[midway, sloped, fill=white] {annotation};
          \end{tikzpicture}
          \caption{\label{fig:derived-annotation-example-sg}}
        \end{subfigure}
        \caption{\label{fig:derived-annotation-example}An example of a derived property in an entity}
      \end{figure}

      Another interesting annotation to mention, is the \texttt{inverse = <var>} annotation as shown for the \texttt{courses} property of the \texttt{Teacher} entity in \cref{fig:webdsl-properties-example}. The inverse annotation is introduced to prevent data duplication in the database. To continue with the example of \texttt{Teacher} and \texttt{Course} of \cref{fig:webdsl-properties-example}, the \texttt{Course} table saves the corresponding teacher, and when a teacher is fetched from the database, the \texttt{courses} property is instantiated according to the data in the \texttt{Course} table. When specifying \texttt{inverse=teacher}, the Statix specification has to validate that the entity mentioned in the property type (\texttt{Course} in this case) has the \texttt{teacher} property, and that the type of that \texttt{teacher} property is equal to the type of the entity that the inverse annotation was declared in (\texttt{Teacher} in this example). To prevent a situation where none of the two entities is responsible for saving the data, a double inverse annotation is not allowed. To enforce this, another constraint has to be added, namely that the \texttt{teacher} property of \texttt{Course} does not have an inverse annotation. The only way to reliably check this is to save the annotation \texttt{INVERSE()} in the scope graph.

    \subsection{Entity Hierarchy and the Name Property}

      Similar to \texttt{Object} in the Java programming language, WebDSL also has a root of the entity hierarchy, namely \texttt{Entity}. If a defined entity does not explicitly inherit from another entity, it will automatically inherit from \texttt{Entity}. This built-in superclass is convenient to store properties that all entites will have out of the box, such as the property \texttt{id} of type \texttt{UUID} and the property \texttt{created} of type \texttt{DateTime}. User-defined entities are not allowed redefine such properties, but they may to edit the values. An exception to this rule is the property \texttt{name} of type \texttt{String} that all entities have by default, but may be overridden once by sub-entities.

      To achieve the overridability, we can re-use the property annotations in the scope graph as explained in previous section. The \texttt{name} property of the built-in entity \texttt{Entity} gets a \texttt{OVERRIDABLE()} annotation declared in the scope of \texttt{Entity}, and when attempting to catch duplicate property definitions, we must discard properties from parents that have the \texttt{OVERRIDABLE()} property. An example of the overriding is shown in \cref{fig:name-property-overriding-example} and the Statix code to discard overridable properties is shown in \cref{fig:overridable-properties-statix}. In the Statix rules, there are now two predicates to prevent duplicates: one for within the entity, and another one to check inherited properties. The difference is rules allows for better error messages, but most importantly allows us to only discard properties with the \texttt{OVERRIDABLE()} annotation from inherited properties. At the point of writing this thesis, the built-in name property is the only use case for the \texttt{OVERRIDABLE()} annotation and it is not possible to mark a property as overridable by code.

      \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m
  entity Person {
    name : String
  }
          \end{minted}
          \caption{\label{fig:name-property-overriding-example-webdsl}}
        \end{subfigure}
        \begin{subfigure}[b]{0.7\textwidth}
          \centering
          \begin{tikzpicture}
            \node (s_m) [scope]   at(-1, 0) {s\_m};
            \node (s_e) [scope]   at(1.5, -2.5) {s\_entity};
            \node (s_p) [scope]   at(-1, -2.5) {s\_person};
            \node (t_e) [decl]  at(5, 0.5) {Entity : ENTITY("Entity", s\_e)};
            \node (t_p) [decl]  at(5, -0.5) {Person : ENTITY("Person", s\_person)};
            \node (t_multi) [decl]  at(6.5, -1.5) {...};
            \node (t_name1) [decl]  at(6.5, -2.5) {name : String};
            \node (t_anno) [decl]  at(7, -3.5) {name : OVERRIDABLE()};
            \node (t_name2) [decl]  at(-1, -4.5) {name : String};
  
            \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
            \draw[decl edge] (s_m.east) -- (t_e.west) node[midway, sloped, fill=white] {type};
            \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
            \draw[decl edge] (s_e.east) -- (t_multi.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_e.east) -- (t_name1.west) node[midway, sloped, fill=white] {var};
            \draw[decl edge] (s_e.east) -- (t_anno.west) node[midway, sloped, fill=white] {annotation};
            \draw[decl edge] (s_p.south) -- (t_name2.north) node[midway, sloped, fill=white] {var};
          \end{tikzpicture}
          \caption{\label{fig:name-property-overriding-example-sg}}
        \end{subfigure}
        \caption{\label{fig:name-property-overriding-example}An example of overriding the \texttt{name} property}
      \end{figure}

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
  module x
  rules
    declProperties maps declProperty(*, *, list(*), list(*))
    declProperty : scope * string * string * TYPE
    declProperty(s, ent, x, sortType) :-
      validPropertyName(x),
      declareVar(s, x, sortType),
      resolveLocalProperty(s, x) == [_]
        | error $[Property [x] of entity [ent] is defined multiple times] @x,
      noDuplicateVarDefsInSuper(s, x)
        | error $[Cannot override existing entity property [x]] @x.

    noDuplicateVarDefsInSuper : scope * string
    noDuplicateVarDefsInSuper(s_sub, x) :- { xs nonOverridable }
      resolveProperty(s_sub, x) == xs,
      withoutAnnotation(xs, OVERRIDABLE()) == nonOverridable,
      amountNonOverridableOk(nonOverridable).

    amountNonOverridableOk : list((path * (string * TYPE)))
    amountNonOverridableOk(_) :- false.
    amountNonOverridableOk([]).
    amountNonOverridableOk([_]).
        \end{minted}
        \caption{\label{fig:overridable-properties-statix}Statix rules for overridable entity properties}
      \end{figure}

  \section{\label{sec:function-template-overloading}Function and Template Overloading}

    Function overloading is the practice of defining multiple functions with the same name, that differ in argument types or in the amount of arguments. Before running the WebDSL program, the compiler determines what instance of the function will be run, based on the types of the function call arguments. WebDSL supports overloading for both functions and templates, and their implementation in the static analysis is the same. The concepts and solutions explained in this section are therefore applicable for both. An example of template overloading is shown in \cref{fig:template-overloading-example}. In the rest of this section we will talk about functions but the concept is exactly the same for templates.

    \begin{figure}
      \begin{minted}[firstline=1]{\webdsl}
module m

  entity Animal {
    name : String
  }
  entity Cat : Animal {
    breed : String
  }

  template description(a : Animal) {
    "~a.name"
  }
  template description(c : Cat) {
    "~c.name (Breed: ~c.breed)"
  }
      \end{minted}
      \caption{\label{fig:template-overloading-example}An example of defining overloaded templates in WebDSL}
    \end{figure}

    Overloading complicates the static analysis in two ways. The first and easiest to implement is that functions may now be defined multiple times with the same name, as long as the amount of arguments and argument types do not exactly match. The Statix rules that achieve this are shown in \cref{fig:statix-overloaded-function-definitions}. The essence of the rules is that all functions with the relevant name are retrieved, and the declarations with argument types exactly matching with the relevant types are counted. The resulting number should be 1, namely the newly declared function.

    \begin{figure}
      \begin{minted}[firstline=3]{\statix}
module m
rules
  // predicate that defines when there are overlapping function signatures
  noDuplicateFunDefs : scope * string * list(TYPE)
  noDuplicateFunDefs(s, f, ts) :- { ps }
    resolveFunction(s, f) == ps,
    amountOfFunDeclsWithArgs(ps, ts, 0) == 1.

  // helper function for noDuplicateFunDefs that counts the amount
  // of functions with a given name and argument types
  amountOfFunDeclsWithArgs : list((path * (string * TYPE))) 
    * list(TYPE) * int -> int
  amountOfFunDeclsWithArgs([], _, n) = n.
  amountOfFunDeclsWithArgs([(_, (_, FUNCTION(_, types, _, _))) | tail], types, n)
    = amountOfFunDeclsWithArgs(tail, types, i) :- i #= n + 1.
  amountOfFunDeclsWithArgs([_ | tail], types, n)
    = amountOfFunDeclsWithArgs(tail, types, n).
      \end{minted}
      \caption{\label{fig:statix-overloaded-function-definitions}Statix rules for allowing overloaded function definitions}
    \end{figure}

    Now that the static analysis allows for overloaded functions and templates to be defined, the code that typechecks function calls and template calls should be updated to reflect the new changes. The semantics of resolving the correct overloaded function or template are listed below. A practical example of how these rules work is shown in \cref{fig:template-overloading-referencing-example}.

    \begin{enumerate}
      \item Retrieve all function signatures with the matching name from the scope graph
      \item Filter the result to end up with function signatures with matching arity (amount of arguments) and compatible argument types.
      \item If the filtered result is exactly one signature: this is the function that will be called
      \item If the filtered result is more than one signature: choose the signature with the "most specific" argument types:
      \begin{itemize}
        \item If there are exactly matching types, always choose this one.
        \item Otherwise; count the amount of \texttt{INHERIT} edges that have to be taken from the given expression types to the function argument types, and choose the signature with the least total edges taken.
      \end{itemize}
    \end{enumerate}

    \begin{figure}
      \begin{minted}[firstline=1]{\webdsl}
module m

  entity Animal {
    name : String
  }
  entity Cat : Animal {
    breed : String
  }

  template description(a : Animal) {
    "~a.name"
  }
  template description(c : Cat) {
    "~c.name (Breed: ~c.breed)"
  }

  page p {
    var a := Animal{ name := "Alice" }
    var c := Cat{ name := "Charlie", breed := "Sphynx" }

    description(a) // will output "Alice"
    description(c) // wil output "Charlie (Breed: Sphynx)"
  }
      \end{minted}
      \caption{\label{fig:template-overloading-referencing-example}An example of referencing overloaded templates in WebDSL}
    \end{figure}

    The implementation of resolving the correctly overloaded function according to the listed semantics is shown in \cref{fig:statix-overloaded-function-calls}. The essence of the semantics is encoded in the Statix rules, but the brevity and elegancy is lost due to many helper predicates being required to transform the data into the correct forms to perform the queries that calculate the inheritance edges, and filter the function signatures accordingly. Note that the \texttt{typeOfFunctionCall} predicate is not specific to functions, because the signature requires a string and a list of expressions, which causes the predicate to be re-usable for resolving template calls.

    \begin{figure}
      \begin{minted}[firstline=3]{\statix}
module m
rules
  typeOfFunctionCall : scope * string * list(Exp) 
    * list((path * (string * TYPE))) -> TYPE
  typeOfFunctionCall(s, f, args, funSigs) = t :- { argTypes f' result }
    argTypes == typesOfExps(s, args),
    result == mostSpecificSigs(
      argTypes
      , typeCompatibleSigs(funSigs, argTypes
    )),
    [(f', FUNCTION(_, _, t, _))] == result
      | error $[Cannot resolve function [f] with compatible argument types] @f.

  // function that gets all functions/templates with matching name
  // and compatible argument types
  typeCompatibleSigs : list((path * (string * TYPE))) * list(TYPE)
    -> list((string * TYPE))
  /* implementation not shown for brevity */
    
  // function that prunes the list of compatible signatures
  // to a list of most specific signatures
  mostSpecificSigs : list(TYPE) * list((string * TYPE)) -> list((string * TYPE))
  // In case no functions are compatible, return empty list
  mostSpecificSigs(args, []) = [].
  // In case of only one compatible signature, return that
  mostSpecificSigs(args, fs@[_]) = fs.
  mostSpecificSigs(args, sigs) = mostSpecificSigs_helper(args, sigs, 
    matchingSigs(stripRefTypes(args), sigs)).

  // helper function for mostSpecificFunSigs that returns
  // the exactly matching signatures if they exists,
  // else return the most specific (least inheritance) signatures
  mostSpecificSigs_helper : list(TYPE) * list((string * TYPE))
    * list((string * TYPE)) -> list((string * TYPE))
  mostSpecificSigs_helper(args, sigs, matching) = matching.
  mostSpecificSigs_helper(args, sigs, [])       = 
    filterLeastInheritanceAmount(
      minOfList(inheritanceAmounts) 
      , zipInheritanceAmountWithSig(inheritanceAmounts, sigs)) :-
    inheritanceAmounts == inheritanceAmounts(args, sigs).
  
  // at least ten more helper predicates are not shown that calculate
  // the amount of inheritance edges and perform the filtering
      \end{minted}
      \caption{\label{fig:statix-overloaded-function-calls}Statix rules for resolving overloaded function calls}
    \end{figure}

    \textbf{Possible TO-DO:}
    \begin{itemize}
      \item Change implementation to throw an error when an overloaded function is not "strictly better" than another (e.g. another one has a more specific argument type for at least one of the arguments).
    \end{itemize}

  \section{\label{sec:actions-and-submitting-forms}Placeholders, Actions and Submitting Forms}

    Forms are the basis of most information systems on the web. WebDSL has linguistically integrated forms through inputs and actions. The static analysis of referencing actions and placeholders is unlike variable referencing, due to their scoping semantics. Actions abd placeholders are defined in pages or templates and may be referred to in the rest of the page or function body. Unlike variables, actions and placeholders do not follow the declare-before-use principle (explained in \cref{subsec:simple-variables}). Actions and placeholders may be defined anywhere in the body, and referenced from anywhere in the body, but there is a twist. Inside the action body, the statements and expressions may reference variables defined in the template or page body, and thus the scope of the action must be linked to the scope of the template of page in some way.
    
    Summarized, actions and placeholders cannot be declared in the scope they are defined in, because that scope follows a declare-before-use regime, but the body of an action must have access to the scope it was declared in. As a solution to this challenge, the Statix rules for declaring a page or template were altered to not only create a scope for its body, but create an additional scope where placeholders and actions will be declared. This scope is passed along such that variables are queryable using the regular function body scope, and querying placeholders and actions is available using the additional scope. An example of an action and its representation in the scope graph is shown in \cref{fig:actions-example}.

    \begin{figure}
      \begin{subfigure}[b]{0.3\textwidth}
        \begin{minted}[firstline=1]{\webdsl}
module m

entity Person {
  firstname : String
}

template t {
  var person := Person{}

  form {
    input(person.firstname)
    submit a() { "Save" }
  }

  action a() {
    person.save();
    return p();
  }
}
        \end{minted}
        \caption{\label{fig:actions-example-webdsl}}
      \end{subfigure}
      \begin{subfigure}[b]{0.7\textwidth}
        \centering
        \begin{tikzpicture}
          \node (s_m) [scope]   at(-2, 0) {s\_m};
          \node (t_p) [decl]  at(4, 0.5) {Person : ENTITY("Person", s\_person)};
          \node (t_t) [decl]  at(3, -0.5) {t : Template("t", []])};
          \node (s_p) [scope]   at(-2, -2.5) {s\_person};
          \node (t_p_name) [decl]  at(-2, -4.3) {firstname : String};
          \node (s_t) [scope]   at(2, -2.5) {s\_t};
          \node (s_t_body) [scope]   at(0.7, -5) {s\_t\_body};
          \node (s_t_body2) [scope]   at(0.7, -6.8) {s\_t\_body2};
          \node (t_t_p) [decl] at (-3, -6.8) {person : Person};
          \node (s_a) [scope]   at(0.7, -8.6) {s\_a};
          \node (s_t_pha) [scope]   at(3.3, -5) {s\_t\_pha};
          \node (t_a) [decl]  at(3.3, -8) {a : ACTION("a", [])};

          \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
          \draw[decl edge] (s_m.east) -- (t_t.west) node[midway, sloped, fill=white] {template};
          \draw[scope edge] (s_p.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
          \draw[decl edge] (s_p.south) -- (t_p_name.north) node[midway, sloped, fill=white] {var};
          \draw[scope edge] (s_t.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
          \draw[scope edge] (s_t_body.north) -- (s_t.south) node[midway, sloped, yshift=1ex] {P};
          \draw[scope edge] (s_t_body2.north) -- (s_t_body.south) node[midway, xshift=-1ex] {P};
          \draw[decl edge] (s_t_body2.west) -- (t_t_p.east) node[midway, sloped, fill=white] {var};
          \draw[scope edge] (s_a.north) -- (s_t_body2.south) node[midway, xshift=-1ex] {P};
          \draw[scope edge] (s_t_pha.north) -- (s_t.south) node[midway, sloped, yshift=1ex] {P};
          \draw[decl edge] (s_t_pha.south) -- (t_a.north) node[midway, sloped, fill=white] {function};
        \end{tikzpicture}
        \caption{\label{fig:actions-example-sg}}
      \end{subfigure}
      \caption{\label{fig:actions-example}An example of defining and referencing actions}
    \end{figure}

    The updated Statix rules for typechecking a page or template definition, and defining actions in shown in \cref{fig:actions-placeholders-statix}. The Statix rules contain a separate predicate \texttt{templateActionOk} where the last boolean parameter indicates whether the action should be declared or not, and this is passed to \texttt{optionallyDeclareTemplate}. The declaration is optional because it is possible to create a form with a submit button that defines an action inline; an anonymous action in some sense. The anonymous inline action definition can now be type-checked by re-using the \texttt{templateActionOk} predicate.

    The Statix rules which implement the placeholders and actions code behave correctly because of Statix' constraint scheduling algorithm as first described by in the original Statix paper \autocite{VanAntwerpen2018} and further improved by Rouvoet et al. \autocite{RouvoetAPKV20}.

    \begin{figure}
      \begin{minted}[firstline=3]{\statix}
module m
rules
  defineTemplateOk(s, DefineTemplate(mods, t
      , FormalArgs(args), _, elements))
    :- {fargTypes s_template s_pha s_body}
    new s_template, s_template -DEF-> s,
    argTypes == typesOfArgs(s, args),
    declareParameters(s_template, zipArgTypes(fargs, argTypes)),
    new s_pha, s_pha -P-> s_template,   // scope for placeholders and actions
    new s_body, s_body -P-> s_pha,      // scope for template body
    declareTemplate(s, t, argTypes, isAjaxTemplate(mods)),
    overriddenElementExists(s, Template(), t, isAjaxTemplate(mods)),
    templateElementsOk(s_body, s_pha, elements).

  templateElementOk(s, _, s_pha
    , Action2TemplateElement(Action(_, a, FormalArgs(args), Block(stmts))))
    :- templateActionOk(s, s_pha, a, args, stmts, TRUE()).

  templateActionOk : scope * scope * string
    * list(FormalArg) * list(Statement) * BOOL
  templateActionOk(s, s_pha, a, args, stmts, declare)
    :- {s_fun s_fun_body argTypes}
    new s_fun, s_fun -P-> s,
    argTypes == typesOfArgs(s, args),
    declareParameters(s_fun, zipArgTypes(args, argTypes)),
    new s_fun_body, s_fun_body -P-> s_fun,
    optionallyDeclareAction(s_pha, a, args, argTypes, declare),
    stmtsOk(s_fun_body, stmts, PAGE(_, _)).

  optionallyDeclareAction : scope * string * list(FormalArg) * list(TYPE) * BOOL
  optionallyDeclareAction(_, _, _, _, FALSE()).
  optionallyDeclareAction(s, a, args, ts, TRUE())
    :- declareAction(s, a, args, ts).
      \end{minted}
      \caption{\label{fig:actions-placeholders-statix}Statix rules for declaring actions}
    \end{figure}

  \section{\label{sec:type-extension}Type Extension}

    WebDSL allows the developer to define types such as entities or use existing built-in types such as strings and dates. Often times, when working on a new functionality for existing applications, developers want to extend existing entities with new properties or functions. To this end, WebDSL allows for entity extension across modules. In addition to entities, WebDSL also allows extension of built-in types. The built-in types can not be extended with arbitrary properties or functions. Since the WebDSL built-in types are based on Java types, developers can expose properties of those Java types for use in WebDSL code. In this section we discuss how we implemented these semantics in Statix.

    \Cref{fig:entity-extension-example-webdsl} shows a WebDSL program containing the entity \texttt{Person} with one property and an extension of that entity with another property and a function. In \cref{fig:entity-extension-example-sg}, we show how we represent the program in a scope graph. When a (partial) entity is defined, a declaration is made in the scope graph under the \texttt{extendscope} relation that declares the scope linked to the name of the entity. When declaring the type in the module (such as \texttt{Entity("person", s\_person)}), all scopes linked to the entity are retrieved from the scope graph and linked together using \texttt{EXTEND} edges.

    \begin{figure}
      \begin{subfigure}[b]{0.4\textwidth}
        \begin{minted}[firstline=1]{\webdsl}
module m

entity Person {
  firstname : String
}

extend entity Person {
  lastname : String

  function logname() {
    log("~firstname + ~lastname");
  }
}
        \end{minted}
        \caption{\label{fig:entity-extension-example-webdsl}}
      \end{subfigure}
      \begin{subfigure}[b]{0.6\textwidth}
        \centering
        \begin{tikzpicture}
          \node (s_m) [scope]   at(-4, 0) {s\_m};
          \node (t_p_1) [decl]  at(2, 2.5) {Person : s\_person};
          \node (t_p_2) [decl]  at(3, 1.25) {Person : s\_person\_2};
          \node (t_p) [decl]  at(2, 0) {Person : ENTITY("Person", s\_person)};
          \node (s_p_1) [scope]   at(-4, -2) {s\_person};
          \node (s_p_2) [scope]   at(0, -2) {s\_person\_2};
          \node (t_p_1_firstname) [decl]  at(-4, -4) {firstname : String};
          \node (t_p_2_lastname) [decl]  at(1.5, -4) {lastname : String};
          \node (t_p_2_logname) [decl]  at(-2.5, -5) {logname : FUNCTION("logname", [], Void)};

          \draw[decl edge] (s_m.east) -- (t_p_1.west) node[midway, sloped, fill=white] {extendscope};
          \draw[decl edge] (s_m.east) -- (t_p_2.west) node[midway, sloped, fill=white] {extendscope};
          \draw[decl edge] (s_m.east) -- (t_p.west) node[midway, sloped, fill=white] {type};
          \draw[scope edge] (s_p_1.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
          \draw[scope edge] (s_p_2.north) -- (s_m.south) node[midway, sloped, yshift=1ex] {DEF};
          \draw[scope edge] (s_p_1.east) to [bend right]  node[midway, sloped, yshift=-1ex] {EXTEND} (s_p_2.west);
          \draw[scope edge] (s_p_2.west) to [bend right]  node[midway, sloped, yshift=1ex] {EXTEND} (s_p_1.east);
          \draw[decl edge] (s_p_1.south) -- (t_p_1_firstname.north) node[midway, sloped, fill=white] {var};
          \draw[decl edge] (s_p_2.south) -- (t_p_2_lastname.north) node[midway, sloped, fill=white] {var};
          \draw[decl edge] (s_p_2.south) -- (t_p_2_logname.north) node[midway, sloped, fill=white] {function};
        \end{tikzpicture}
        \caption{\label{fig:entity-extension-example-sg}}
      \end{subfigure}
      \caption{\label{fig:entity-extension-example}An example of extending entity scopes}
    \end{figure}

    The Statix rules that transform a WebDSL program with extended entities into the scope graph as shown in \cref{fig:entity-extension-example} are listed in \cref{fig:extend-entity-statix}. Note that the original entity does not need to import all modules in which it is extended. \textbf{Line 9} of \cref{fig:extend-entity-statix} shows the regular expression for well-formedness of the path to resolve declarations in the \texttt{extendscopes} relation. It includes the optional \texttt{GLOBAL} edge, which is the edge from the global scope to every module, meaning that entity extensions in all modules, regardless of imports, are the result of the query. \textbf{Line 30} enforces that an \texttt{extend entity} declaration does always import the main entity declarations. The main entity declaration is what separates WebDSL entities from C\# partial classes from WebDSL extend entities: WebDSL entities main entity definition and explicit extensions, as opposed to C\# partial classes that do not have a main definition.

    \begin{figure}
      \begin{minted}[firstline=3]{\statix}
module m
rules
  declareExtendScope : scope * string * scope
  declareExtendScope(s, e, s_extend) :-
    !extendscope[e, s_extend] in s.

  resolveExtendScope : scope * string -> list((path * (string * scope)))
  resolveExtendScope(s, x) = ps :-
    // extended entities do not have to be imported and
    // can be resolved via the global scope edge:
    query extendscope filter P* F* DEF? (IMPORT | IMPORTLIB)? GLOBAL?
      and { e' :- e' == (x, _) }
      min $ < P, $ < F, $ < DEF, $ < IMPORT, $ < IMPORTLIB, $ < GLOBAL,
          P < F, P < DEF, P < IMPORT, P < IMPORTLIB, P < GLOBAL,
          F < DEF, F < IMPORT, F < IMPORTLIB, F < GLOBAL,
          DEF < IMPORT, DEF < IMPORTLIB, DEF < GLOBAL,
          IMPORT < GLOBAL, IMPORTLIB < GLOBAL
      and { (entity, entity_scope), (entity, entity_scope) }
      in s |-> ps.

  declEntity : scope * scope * string * list(EntityBodyDeclaration)
  declEntity(s, s_entity, entity_name, bodydecs) :- { entityType }
    // declare entity_scope to be linked to entity_name
    declareExtendScope(s, entity_name, s_entity),
    // link scopes using EXTEND edges
    extendScopes(resolveExtendScope(s, entity_name), s_entity),
    entityType == ENTITY(entity_name, s_entity),
    declareType(s, entity_name, entityType).

  declExtendEntity : scope * string * list(EntityBodyDeclaration)
  declExtendEntity(s, entity_name, bodydecs) :- {s_extend_entity entity_scopes}
    resolveType(s, entity_name) == [(_, (_, ENTITY(_, _)))]
      | error $[Entity [entity_name] is not defined],
    new s_extend_entity, s_extend_entity -DEF-> s,
    declareExtendScope(s, entity_name, s_extend_entity),
    extendScopes(resolveExtendScope(s, entity_name), s_extend_entity),
    declEntityBody(s_extend_entity, entity_name, bodydecs).

  extendScopes maps extendScope(list(*), *)
  extendScope : (path * (string * scope)) * scope
  extendScope((_, (_, s)), s). // Do not inherit own scope
  extendScope((_, (_, s')), s) :-
    s -EXTEND-> s'.
      \end{minted}
      \caption{\label{fig:extend-entity-statix}Statix rules for extending entities}
    \end{figure}

  \section{\label{sec:module-system}Module system}

    The paper that introduced WebDSL \autocite{Visser2007} contains the following description of the its module system: {``a very simple module system has been chosen that supports distributing functionality over files, without separate compilation''}. We describe the current WebDSL module system as having transitive and symmetric imports. The implementation of the module system in the current compiler maintains a list of modules of which an application consists. When a module is imported by the main application file or transitively imported, the module is added to the list and its definitions are visible to all other modules in the list. An example application with these semantics and its scope graph is visualized in \cref{fig:current-module-system}. The implementation of these semantics are listed in \cref{fig:current-module-system-statix}.

    The modelling of this system causes an explosion in this amount of import edges between module scopes, as it is a fully connected graph for all modules that are (transitively) imported by the application root. The amount of import edges would scale quadratically with the number of imported modules:

    $$import edges = \#modules(\#modules - 1) + \#modules$$

    The additional $+ \#modules$ in this calculation is for the import edges to the global scope.

    \begin{figure}
      \begin{subfigure}[b]{0.2\textwidth}
        \begin{subfigure}[b]{1\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
application a
  imports m1
          \end{minted}
          \caption{\label{fig:current-module-system-webdsl-a}}
        \end{subfigure}
        \begin{subfigure}[b]{1\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m1
  imports m2
          \end{minted}
          \caption{\label{fig:current-module-system-webdsl-m1}}
        \end{subfigure}
        \begin{subfigure}[b]{1\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m2
          \end{minted}
          \caption{\label{fig:current-module-system-webdsl-m2}}
        \end{subfigure}
        \begin{subfigure}[b]{1\textwidth}
          \begin{minted}[firstline=1]{\webdsl}
module m3
          \end{minted}
          \caption{\label{fig:current-module-system-webdsl-m3}}
        \end{subfigure}
        % \caption{\label{fig:current-module-system-webdsl}}
      \end{subfigure}
      \begin{subfigure}[b]{0.8\textwidth}
        \centering
        \begin{tikzpicture}
          \node (s_global) [scope]   at(0, 0) {s\_g};
          \node (s_a) [scope]   at(0, -4) {s\_a};
          \node (s_m1) [scope]   at(-2, -6) {s\_m1};
          \node (s_m2) [scope]   at(2, -6) {s\_m2};
          \node (s_m3) [scope]   at(4, -6) {s\_m3};
          \node (d_app) [decl]  at(-3, 3) {\_APPLICATION\_SCOPE : s\_a};
          \node (d_a) [decl]  at(-3, 2) {a : s\_a};
          \node (d_m1) [decl]  at(-1, 2) {m1 : s\_m1};
          \node (d_m2) [decl]  at(1, 2) {m2 : s\_m2};
          \node (d_m3) [decl]  at(3, 2) {m3 : s\_m3};

          \draw[decl edge] (s_global.north) -- (d_app.south) node[midway, sloped, fill=white] {mod};
          \draw[decl edge] (s_global.north) -- (d_a.south) node[midway, sloped, fill=white] {mod};
          \draw[decl edge] (s_global.north) -- (d_m1.south) node[midway, sloped, fill=white] {mod};
          \draw[decl edge] (s_global.north) -- (d_m2.south) node[midway, sloped, fill=white] {mod};
          \draw[decl edge] (s_global.north) -- (d_m3.south) node[midway, sloped, fill=white] {mod};

          \draw[scope edge] (s_a.north) -- (s_global.south) node[midway, sloped, yshift=1ex] {IMPORT};
          \draw[scope edge] (s_m1.north) -- (s_global.south) node[midway, sloped, yshift=1ex] {IMPORT};
          \draw[scope edge] (s_m2.north) -- (s_global.south) node[midway, sloped, yshift=1ex] {IMPORT};
          \draw[scope edge] (s_m3.north) -- (s_global.south) node[midway, sloped, yshift=1ex] {IMPORT};

          \draw[scope edge] (s_a.west) to [bend right]  node[midway, sloped, yshift=1ex] {IMPORT} (s_m1.north);
          \draw[scope edge] (s_m1.north) to [bend right]  node[midway, sloped, yshift=-1ex] {IMPORT} (s_a.west);
          
          \draw[scope edge] (s_a.east) to [bend right]  node[midway, sloped, yshift=-1ex] {IMPORT} (s_m2.north);
          \draw[scope edge] (s_m2.north) to [bend right]  node[midway, sloped, yshift=1ex] {IMPORT} (s_a.east);

          \draw[scope edge] (s_m1.east) to [bend right]  node[midway, sloped, yshift=-1ex] {IMPORT} (s_m2.west);
          \draw[scope edge] (s_m2.west) to [bend right]  node[midway, sloped, yshift=1ex] {IMPORT} (s_m1.east);
        \end{tikzpicture}
        \caption{\label{fig:current-module-system-sg}}
      \end{subfigure}
      \caption{\label{fig:current-module-system}An example of the current WebDSL module system}
    \end{figure}

    \begin{figure}
      \begin{minted}[firstline=3]{\statix}
module m
rules
  unitOk(s_global, Application(app, sections)) :- {s_app}
    new s_app, s_app -IMPORT-> s_global,
    declareMod(s_global, app, s_app),
    declareMod(s_global, "_APPLICATION_SCOPE", s_app),
    importModules(s_global, s_app, app, sections),
    rootPageDefined(s_app, app).

  unitOk(s_global, Module(m, sections)) :- {s_mod}
    new s_mod, s_mod -IMPORT-> s_global,
    declareMod(s_global, m, s_mod),
    importModules(s_global, s_mod, m, sections),
    importedByApplicationRoot(s_global, s_mod, m).

  importModules : scope * scope * string * list(Section)
  importModules(s_global, s, m, sections) :-
    declareImports(s_global, m, sections),
    extendModuleScope(s_global, m, s).

  extendModuleScope : scope * string * scope
  extendModuleScope(s_global, m, s) :- {modules}
    resolveImport(s_global, m) == modules,
    importModulesInScope(s_global, s, modules).

  importedByApplicationRoot : scope * scope * string
  importedByApplicationRoot(s_global, s_mod, mod) :- {s_app}
    resolveMod(s_global, "_APPLICATION_SCOPE") == [(_, (_, s_app))],
    try { query () filter IMPORT*
                    and { s_app' :- s_app' == s_app }
                    in s_mod |-> [_|_]
        } | warning $[Module is not imported by the application root] @mod.
      \end{minted}
      \caption{\label{fig:current-module-system-statix}Statix rules for modelling the current module system}
    \end{figure}

    This representation of the WebDSL module system in scope graphs is functional, however, we found this to be extremely taxing on the run time performance of an analysis. To gather information about the performance of the current module system semantics in the WebDSL Statix specification, we conducted an experiment where the same program was analyzed multiple times, but with the addition of extra empty modules. The result as shown in \cref{fig:statix-performance-current-modules} confirms our suspicion.

    To run the experiment, we used a 2019 MacBook Pro running macOS Montery 12.2. The machine has a 2,3 GHz 8-core Intel Core i9 with 64 GB RAM available, of which 8 GB was dedicated to the evaluation scripts. The evaluation scripts\footnote{https://github.com/metaborg/statix-benchmark/} were configured to analyze the same application with different amounts of empty modules. Using the Java Microbenchmark Harness\footnote{https://github.com/openjdk/jmh}, we timed the run time of the Statix specification using 5 warmup iterations and 20 regular iterations.

    \begin{figure}
      \pgfplotstableread{
   	    size  time
        0     1.25
    	  1     1.39
    	  2     1.72
    	  3     3.17
    	  4     4.13
    	  5     7.81
    	  6     28.92
      }\parsingbenchmarkresults
      \begin{tikzpicture}
        \begin{axis} [ybar,
            axis on top,
            width=\textwidth,
            title={Current Module System Run Time},
            bar width=30,
            ymin=0,
            ylabel={Run time (s)},
            xlabel={Amount of modules},
            nodes near coords,
            xtick=data,
            xticklabels={1, 2, 5, 10, 20, 50, 100},
            enlarge x limits=0.3
            ]
        
          \addplot table[x=size, y=time] {\parsingbenchmarkresults};
        \end{axis}
      \end{tikzpicture}
      \caption{\label{fig:statix-performance-current-modules}Run time of WebDSL Statix definition with the current module system.}
    \end{figure}

    From the results shown in \cref{fig:statix-performance-current-modules}, we argue that the implementation of the current WebDSL module system in Statix, approach does not scale to real world applications. We attempted to run the Statix specification on two open-source WebDSL applications.

    \begin{itemize}
      \item \textbf{Reposearch\footnote{\url{https://codefinder.org/}, Source code: \url{https://github.com/webdsl/reposearch/}}:} A source code search engine that helps to find implementation details and example usages. Reposearch consists of 16 main files, 19 library files and 1 standard library file, totalling at 8,722 lines of code spread over 36 files.
      \item \textbf{YellowGrass\footnote{\url{https://yellowgrass.org/}, Source code: \url{https://github.com/webdsl/yellowgrass/}}:} A tag based issue tracker similar to GitHub Issues, complete with access control and used daily by WebDSL developers. YellowGrass consists of 54 WebDSL files plus 20 WebDSL library files and 1 standard library file, coming to a total of 12,898 lines of code spread over 75 files.
    \end{itemize}

    Running the static analysis on Reposearch took roughly 25 minutes, and on YellowGrass it took more than 8 hours.

    \subsection{\label{subsec:revised-module-system}Revised WebDSL Module System}

      We designed a revised module system for WebDSL, in an attempt to improve the static analysis run time. In addition, the revised module system is designed to largely keep existing WebDSL applications as they are, such that no substantial effort is required to adhere to the revised module system. We considered three options for the revised module system.
      
      \paragraph{Everything is Global} The first option boils down to getting rid of imports altogether and using one global scope. The upside of this approach is that existing WebDSL applications do not have to be changed at all, since the import statement will be deprecated and it does not change the behaviour of programs. The downside is that, since all declarations and resolving takes place in the global scope, it could negate the possible performance boosts provided by the concurrent \autocite{AntwerpenV21} or incremental \autocite{ZwaanAV22} Statix solver.

      \paragraph{Strict Modules} The second option is to get rid of transitive and symmetric imports, making the WebDSL module system similar to that of simple toy languages such as LMR: Language with Modules and Records \autocite{Neron2015}. Existing WebDSL applications have to be extended with more import statements to correctly resolve all the references that are now transitively or symmetrically imported. This module system allows for more transparent behaviour; a reference to a definition from another module requires the importing of that module.

      \paragraph{Strict Modules With Wildcard Imports} The third and last option we consider is similar to the strict module system from previous paragraph, but allowing wildcard imports for the convenience of the developer. Assuming that existing WebDSL applications are structured correctly in terms of nesting of modules, using concepts defined in other modules can be imported in one statement. The downside of using wildcard imports is a potential increase in import edges of which some are unused.

      We implemented the changes required in Reposearch and YellowGrass to apply the latter two module systems. Reposearch required 92 extra import statements, spread over 16 files\footnote{\url{https://github.com/webdsl/reposearch/tree/experiment/strict-imports}} and YellowGrass required 328 extra imports spread over 54 files\footnote{\url{https://github.com/webdsl/yellowgrass/tree/experiment/strict-imports}}. In both systems, the strict import semantics required about 6 new imports per file. Using the wildcard import system, this was reduced to about 4 per file, requiring 75 instead of 92 for Reposearch\footnote{\url{https://github.com/webdsl/reposearch/tree/experiment/wildcard-imports}} and 193 instead of 328 for YellowGrass\footnote{\url{https://github.com/webdsl/yellowgrass/tree/experiment/wildcard-imports}}

      \begin{figure}
        \pgfplotstableread{
          size  current global  strict  wildcard
          0     1.25    1.81    0.86    0.88
          1     1.39    1.81    0.90    0.86
          2     1.72    1.81    0.96    0.84
          3     3.17    1.81    0.96    0.86
          4     4.13    1.82    0.96    0.89
          5     7.81    1.82    1.10    1.05
          6     28.92   1.82    1.35    1.30
        }\parsingbenchmarkresults
        \begin{tikzpicture}
          \begin{axis} [ybar,
              axis on top,
              width=\textwidth,
              title={Current Module System Run Time},
              legend style={
                legend columns=4,
                at={(0.05,0.95)},
                anchor=north west,
                draw=none
              },
              ymin=0,
              ylabel={Run time (s)},
              xlabel={Amount of modules},
              nodes near coords,
              every node near coord/.append style={font=\tiny},
              xtick=data,
              xticklabels={1, 2, 5, 10, 20, 50, 100}
              ]
          
            \addplot table[x=size, y=current] {\parsingbenchmarkresults};
            \addplot table[x=size, y=global] {\parsingbenchmarkresults};
            \addplot table[x=size, y=strict] {\parsingbenchmarkresults};
            \addplot table[x=size, y=wildcard] {\parsingbenchmarkresults};
            \legend{Current, Global, Strict, Wildcard}
          \end{axis}
        \end{tikzpicture}
        \caption{\label{fig:statix-performance-other-modules}Run time of WebDSL Statix definition with revised module systems.}
      \end{figure}

      \Cref{fig:statix-performance-other-modules} shows the run time of the WebDSL Statix analysis with the different module systems described at the start of this subsection. The figure shows that all of the revised module systems greatly speed up the analysis time. The run time of the strict and wildcard system are similar, while the system where everything is part of the global scope takes slightly longer. We suspect that this is due to negated effects of the concurrent Statix solver that we used for the analysis.

      \begin{table}[h]
        \centering
        \begin{tabular}{ | c || c | c | }
          \hline
          Module System & Reposearch & YellowGrass \\
          \hline
          Current & 1667s & >8 hours \\
          \hline
          Global & 39s & 40s \\
          \hline
          Strict & 51s & 53s \\
          \hline
          Wildcard & 51s & 51s \\
          \hline
        \end{tabular}
        \caption{\label{tbl:statix-performance-other-modules-rs-yg}Run time of WebDSL Statix definition with revised module systems on Reposearch and YellowGrass.}
      \end{table}

      \cref{tbl:statix-performance-other-modules-rs-yg} lists the run time of the different module systems on Reposearch and YellowGrass. Similar to the test with the empty modules, there is a great performance boost from using any of the revised module systems. Surprisingly, the strict and wildcard module system take more time than global module system for YellowGrass. This is in contrast with \cref{fig:statix-performance-other-modules}, so we suspect that having populated modules instead of empty modules impacts the performance of the strict- and wildcard imports by having longer (and therefore more costly) query paths and shadowing rules in a module system with imports.

      Although all revised module systems would massively boost the performance of the WebDSL Statix specification, the run time of analyzing a real world application is still unfit for use in practice. To this end, we need to speed up the analysis time even more. For other performance boosts, as we explain in the next section, a scope graph representation with split modules was required. Since the wildcard import system is more convenient for WebDSL developers, the WebDSL Statix specification is developped with the revised module system that uses wildcard imports.

  \section{\label{sec:built-in-library}Pre-analyzed built-in library}

    WebDSL applications heavily rely on the standard library named \texttt{built-in.app}. It contains all necessary type, page, template and function definitions and even the WebDSL compiler itself depends on this file being present. The \texttt{built-in.app} consists of 3,397 lines of WebDSL code and is by far the largest file in all WebDSL applications.

    The concurrent Statix solver provides speed-ups by distributing the compilation units over the available processor cores on the development machine. However, the granularity of compilation units in the concurrent Statix solver is file-level granularity which results in the run time scaling with the largest file in the project \autocite{AntwerpenV21}. Van Antwerpen and Visser evaluated their concurrent Statix solver on multiple Java projects without dependencies besides the Java standard library (JRE). They indicate that the JRE dominated the run time of the concurrent Statix solver and decided to pre-compute the scope graph for the JRE and statically load it at the start of type-checking.

    We investigated the approach of pre-computing the WebDSL \texttt{built-in.app} scope graph and statically loading it at the start of type checking. However, this requires the modules in WebDSL to be clearly separated and this impacted our choice for a revised module system as explained in the previous section (\cref{subsec:revised-module-system}).

    \begin{figure}
      \pgfplotstableread{
      size  default stxlib
      0     51.23   4.04
      1     51.46   4.61
      }\parsingbenchmarkresults
      \begin{tikzpicture}
        \begin{axis} [ybar,
          axis on top,
          width=\textwidth,
          title={Effect of Pre-Analayzing on Run Time},
          legend style={
            legend columns=2,
            at={(xticklabel cs:0.5)},
            anchor=north,
            draw=none
          },
          bar width=30,
          ymin=0,
          ylabel={Run time (ms)},
          nodes near coords,
          xtick=data,
          xticklabels={Reposearch, YellowGrass},
          enlarge x limits=0.3
          ]
       
          \addplot table[x=size, y=default] {\parsingbenchmarkresults};
          \addplot table[x=size, y=stxlib] {\parsingbenchmarkresults};
          \legend{Default, Pre-analyzed Standard Library}
        \end{axis}
      \end{tikzpicture}
      \caption{\label{fig:statix-performance-built-in-app}Run time of WebDSL Statix definition with and without pre-analyzed standard library \texttt{built-in.app}.}
    \end{figure}

    \Cref{fig:statix-performance-built-in-app} shows a major improvement in run time of the WebDSL Statix specification when the analysis result of the standard library (\texttt{built-in.app}) is pre-computed, and the resulting scope graph is statically loaded at the start of type-checking other projects.

    \subsection{\label{subsec:built-in-extension}Built-in Type Extension}

      In the WebDSL Statix specification, built-in types are declared when processing the WebDSL standard library \texttt{built-in.app}. However, this clashes with our definition of extending types as explained in \cref{sec:type-extension}. The scopes of extended types are combined once, after which the type is declared. In Statix, existing scopes resolved via queries cannot be extended in order to keep the constraint scheduling sound. This does not impact types which are not declared in the standard library (such as all entities), but at first glance, this would nullify our attempt at implementing built-in type extension.

      To combat this challenge, we changed the implementation of the query that resolves types in the WebDSL Statix specification, to the rules listed in \cref{fig:built-in-type-extension-statix}. \textbf{Lines 6, 7 and 8} show that the query for resolving now has a shadowing rule that allows shadowing types that are defined in an imported Statix library.

      \begin{figure}
        \begin{minted}[firstline=3]{\statix}
module m
rules
  resolveType : scope * string -> list((path * (string * TYPE)))
  resolveType(s, name) = typesOf(ts) :-
    query type filter P* F* ((EXTEND? INHERIT*) | (DEF? (IMPORT | IMPORTLIB)?))
               and { e' :- e' == (name, _) }
               // allow shadowing of types defined in an imported statix library
               min $ < IMPORTLIB, P < IMPORTLIB, F < IMPORTLIB,
               EXTEND < IMPORTLIB, INHERIT < IMPORTLIB,
               DEF < IMPORTLIB, IMPORT < IMPORTLIB
               and true
               in s |-> ts.
        \end{minted}
        \caption{\label{fig:built-in-type-extension-statix}Statix rules for built-in type extension in Statix}
      \end{figure}

  \section{\label{sec:statix-string-manipulation}String Manipulation in Statix}

    String manipulation functions are the possibilities that a programming language provides to allow the developer to change or create new strings based on other data. In this section, we discuss the impact of the lack of string manipulation features in Statix.
    
    Statix provides built-in functionalities for integer arithmetic\footnote{\url{https://www.spoofax.dev/references/statix/basic-constraints/\#arithmetic-constraints}}. This feature is useful to, for example, choose the most specific function call to resolve in function or template overloading (\cref{sec:function-template-overloading}). Most other arithmetic such as boolean arithmetic can be encoded by the Statix developer, as we showed in \cref{subsec:boolean-logic}.

    The lack of the string manipulation features in Statix disallows certain WebDSL features, such as generated definitions or static code template expansion, to be encoded in Statix. An example of generated definitions and static code template expansion is shown in \cref{fig:webdsl-generated-definitions-and-expansion}. Generated definitions such as the \texttt{find<Entity>By<Property>} require the Statix specification to build a declaration in the scope graph with a name that is not present in the AST. Because it is impossible to concatenate two strings together, or to capitalize strings, this cannot be encoded in Statix.

    \begin{figure}
      \begin{minted}[firstline=1]{\webdsl}
application a

  // generated definitions:
  entity Person {
    address : String
  }

  function f() {
    // this function is generated by WebDSL:
    var p : Person := findPersonByAddress("");
  }

  // template expansion:
  expand
      Success
      Info
      Warning
      Error
    to alert

  expandtemplate alert to Type{
    template alertType() {
      alert[class="alert-type", all attributes]{
        elements
      }
    }
  }

  template t {
    // templates are defined through the expansion above
    alertSuccess{}
    alertWarning{}
  }
      \end{minted}
      \caption{\label{fig:webdsl-generated-definitions-and-expansion}An example of generated definitions and static code template expansion in WebDSL}
    \end{figure}

    Even though it is not possible to encode this in pure statix, there is a workaround for the generated definitions. Because all information is present in the abstract syntax tree, the generation of the defintions can be seen as a desugaring of the syntax. Following this workaround, we extended the desugaring step of the WebDSL syntax with rules that generate the definitions. The result of the desugaring step is that the names of the generated functions are present in the analysis, and Statix is able to declare the functions.

    The static code template expansion however, does not have such a workaround, because name-binding rules are required. \Cref{fig:webdsl-generated-definitions-and-expansion} shows the \texttt{expandtemplate ... to alert} definition to be declared in one definition, and then \texttt{alert} being referenced in the next definition. This name-binding logic is able to be encoded in Stratego, but it defeats the purpose of using the Statix definition as static analysis.

    In addition to allowing new language concepts to be implemented, supporting string manipulation would also allow better error messages in Statix specifications. For example, the Statix specification could then pretty-print types, function signatures and template signatures to point developers to the error in their code with more accuracy.

    In conclusion, the lack of string manipulation is preventing certain WebDSL language concepts from being encoded in Statix. Additionally, the introduction of string manipulation could increase the user-friendliness of error messages generated by Statix.
