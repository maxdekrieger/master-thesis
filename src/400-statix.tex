% !TEX root = document.tex

\chapter{\label{chap:statix}WebDSL in Statix}

  In this chapter, we go in detail about the implementation of the WebDSL static semantics in Statix, according to the defined semantics in chapter \emph{TO-DO}. First, we introduce the meta-DSL Statix. Next, we describe the implementation of a simple type system in Statix. Lastly, we zoom in on the challenges faced while implementing non-trivial WebDSL features in Statix.

  \section{Introduction to Statix}

    \begin{itemize}
      \item Syntax
      \item Scope graphs
      \item Relations and queries
      \item Boolean logic
    \end{itemize}
  
  \section{Simple Type Systems}

    \subsection{Constant Expressions}

      \begin{itemize}
        \item Typing rules
        \item Type compatibility
      \end{itemize}

    \subsection{Variables}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Declare before use
        \item Shadowing
      \end{itemize}

    \subsection{Entities and properties}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{Functions}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{Pages and Templates}

      \begin{itemize}
        \item Declaration and resolving
      \end{itemize}

  \section{Inheritance}

    \subsubsection{Linking the Scopes}
      The implementation of inheritance requires the scope of the sub- and super-entity to be connected such that Statix queries can resolve to declarations from the super-entity when necessary. To achieve this, we introduce an edge label \texttt{INHERIT} as shown in listing \emph{TO-DO}.
      \begin{lstlisting}
        name-resolution
        labels
          INHERIT // inherit edge label for subclasses
      \end{lstlisting}
      Declarations of sub-entities will generate constraints as shown in listing \emph{TO-DO}.
      \begin{lstlisting}
        defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity super' s_super}
          resolveEntity(s_global, super) == [(_, (super', ENTITY(s_super)))],
          new s_entity, s_entity -INHERIT-> s_super,
          noCircularInheritance(s_entity),
          declEntity(s_global, s_entity, x, bodydecs),
          @super.ref := super'.
      \end{lstlisting}
      First of all, the super-entity refered to in the declaration must refer to an existing entity in the scope graph. Secondly, the new scope belonging to the sub-entity \texttt{s\_entity} is linked to the scope of the super class \texttt{s\_super} via an \texttt{INHERIT} edge. Finally, some additional constraints are generated to make sure no circular inheritance exists and constraints for the entity body declarations of the sub-entity are generated.

      Previously, the resolving of variables was done using the query as shown in listing \emph{TO-DO}
      \begin{lstlisting}
        resolveVar(s, x) = ps :-
          query var filter P* F* IMPORT*
                    and { x' :- x' == x }
                    min $ < P, P < F, F < IMPORT
                    and true
                    in s |-> ps.
      \end{lstlisting}
      The new query in listing \emph{TO-DO} reflects the addition of the \texttt{EXTEND} label. The addition of \texttt{INHERIT*} in the query filter makes all variables declared in ancestors reachable.
      \begin{lstlisting}
        resolveVar(s, x) = ps :-
          query var filter P* F* INHERIT* IMPORT*
                    and { x' :- x' == x }
                    min $ < P, P < F, F < INHERIT, INHERIT < IMPORT
                    and true
                    in s |-> ps.
      \end{lstlisting}

    \subsubsection{Overwriting Functions and Properties}
      Generally, overwriting functions is not allowed in WebDSL. Entity functions are an exception to this such that entity function definitions shadow global function definitions. With the introduction of inheritance there comes another exception, namely that sub-entities are allowed to overwrite function definitions of their ancestors.

      \emph{TO-DO}

    \subsubsection{Entity Type Compatibility}
      A great perk of having inheritance in a language is writing code for that works for super-entities, and then executing this code with sub-entities. To know if the given entity type is compatible with the required entity type, we require a predicate that defines this compatibility. We have created such a predicate while implementing general type compatibility in subsection \emph{TO-DO}, in the form of \lstinline|typeCompatibleB : TYPE * TYPE -> BOOL|.

      With the addition of entity inheritance, we need to expand this definition. To this end, we added the rules as shown in listing \emph{TO-DO}. Given two entity scopes, the \lstinline|inherits(s_sub, s_super)| predicate returns true when the query has one result. The query in the \texttt{inherits} rule requests all paths from scope \texttt{s\_sub} to scope \texttt{s\_super} consisting of only \texttt{INHERIT} edges. Such a path exists if and only if the entity belonging to scope \texttt{s\_sub} inherits the entity belonging to \texttt{s\_super}.

      \begin{lstlisting}
        typeCompatibleB(ENTITY(s_sub), ENTITY(s_super)) = inherits(s_sub, s_super).

        inherits : scope * scope -> BOOL
        inherits(s_sub, s_super) = nonEmptyPathScopeList(ps) :-
          query () filter INHERIT*
                   and { s :- s == s_super }
                   min $ < INHERIT
                   in s_sub |-> ps.

        nonEmptyPathScopeList : list((path * scope)) -> BOOL
        nonEmptyPathScopeList(_)       = FALSE().
        nonEmptyPathScopeList([(_,_)]) = TRUE().
      \end{lstlisting}

  \section{Entity Extension}

  \section{Function and Template Overloading}

  \section{Module system}

  \section{TO-DOs in Statix spec}
  
    Statix spec TO-DOs that most likely are interesting:
    \begin{itemize}
      \item HQL
      \item Access control reference checking
      \item Inclusing \texttt{built-in.app} in analysis
    \end{itemize}

  \section{Possibly: Compose HQL and WebDSL's Type System using Aron's Thesis}

  \section{Reflection on Statix}
