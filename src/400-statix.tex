% !TEX root = document.tex

\chapter{\label{chap:statix}WebDSL in Statix}

  In this chapter, we elaborate on the implementation of the WebDSL static semantics in Statix, using the examples from \cref{chap:webdsl} as a basis. First, we introduce the meta-DSL Statix. Secondly, we describe the implementation of the simple type system that is the core of WebDSL. Next, we address and discuss the challenges faced while implementing non-trivial WebDSL features in Statix and lastly we reflect on the developer experience of using Statix to implement static analyses.

  \section{\label{sec:statix}Introduction to Statix}

    Statix is a constraint-based declarative language for the specification of type systems, introduced in 2018 \autocite{VanAntwerpen2018}. Since then, the meta-DSL Statix has become a part of the Spoofax Language Workbench and allows language developers to implement static analyses to provide language users with useful hints, warnings and errors.

    A Statix specification consists of rules over terms that define constraints. Additionally, Statix rules build and query a \textit{scope graph} \autocite{Neron2015} that provides a language-agnostic representation of a program.

    \subsection{Language Signature}

      \begin{wrapfigure}{r}{0.5\linewidth}
        \capstart
        \begin{minted}[firstline=2]{\statix}
          module x
          signature
            sorts
              Program
              Exp
            
            constructors
              Program : Exp       -> Program
              True    :              Exp
              False   :              Exp
              Int     : string    -> Exp
              Add     : Exp * Exp -> Exp
        \end{minted}
        \caption{\label{fig:statix-signatures}Language signature in Statix}
      \end{wrapfigure}

      \noindent
      Consider a language consisting of Booleans, integers and addition, for which we want to create a type-checker with Statix. First, Statix requires us to declare all types and sorts that we will be using in the rules. The corresponding Statix code is shown in \cref{fig:statix-signatures}.

      So far, our specification consists of two sorts. The \texttt{Program} sort defines the entry point of our language, it has one constructor with an identical name. Next, the sort \texttt{Exp} describes what expressions are allowed. It has four constructors: the Boolean values \texttt{True} and \texttt{False}, \texttt{Int} which requires an integer literal as subterm, and lastly \texttt{Add} which takes two nested expressions as subterms. Examples of valid input according to our defined signature are shown in \cref{fig:statix-valid-input}.

      \begin{figure}[H]
        \begin{lstlisting}[frame=single]
          Program(True())
          Program(Int("42"))
          Program(Add(Int("40"), Int("2")))
          Program(Add(Int("40"), False()))
        \end{lstlisting}
        \caption{\label{fig:statix-valid-input}Valid input terms for the described language}
      \end{figure}

    \subsection{Semantic Types}

      Not all of the valid input terms according to our signature are well-typed. For example, the last term shown in \cref{fig:statix-valid-input} features an addition of the integer literal \texttt{40} and the Boolean value \texttt{False}. Using Statix' constraint solving capabilities, we would like to give feedback to the programmer that the input is ill-typed.

      Given the code in \cref{fig:statix-signatures}, our Statix specification does not yet generate any constraints. Constraints we would like to generate using Statix rules, are that a program must be well-typed and in order for an addition expression to be well-typed, its two subterms must be of integer type.

      \begin{wrapfigure}{r}{0.5\linewidth}
        \vspace{-20pt}
        \capstart
        \begin{minted}[firstline=2]{\statix}
          module x
          signature
            sorts
              TYPE
            
            constructors
              BOOL : TYPE
              INT  : TYPE
        \end{minted}
        \caption{\label{fig:statix-type-signatures}Statix signature for Boolean and integer types}
        \vspace{-40pt}
      \end{wrapfigure}

      To reason about the types of expressions and use them in constraints, we must first define them in our specification, as shown in \cref{fig:statix-type-signatures}. To distinguish input sorts and constructors from semantic types that we will use in our constraints, those sorts and constructors are defined in upper-case. With the new \texttt{TYPE} sort that has two constructors: \texttt{BOOL} and \texttt{INT}, we can start generating constraints on input terms.

    \subsection{Predicates and Rules}

      \Cref{fig:statix-basic-rules} lists the Statix predicates and rules required to generate the constraints we want to be satisfied in order for a program to be well-typed. The type of every Statix predicate must be explicitly declared, for example: \texttt{programOk : Program} declares that the predicate named \texttt{programOk} matches exactly one instantiation sort Program. An instantiation of the \texttt{programOk} predicate is on the line below the signature. In prose English it would read ``A program is well-typed, given that for some type \texttt{T}, the expression \texttt{e} has type \texttt{T}''. The other Statix rule of our small example specification is a \textit{functional predicate}, meaning that it returns a value. All but the last rules of the \texttt{typeOfExp} predicate compute a \texttt{TYPE} for a given expression, without conditions. The last rule of the example does have two conditions, in prose English it would read ``\texttt{e1} plus \texttt{e2} is of type \texttt{INT}, given that \texttt{e1} is of type \texttt{INT} and \texttt{e2} is of type \texttt{INT}''.

      \begin{figure}[H]
        \begin{minted}[firstline=2]{\statix}
          module x
          rules

            programOk : Program
            programOk(Program(e)) :- { T }
              typeOfExp(e) == T.

            typeOfExp : Exp -> TYPE
            typeOfExp(True()) = BOOL().
            typeOfExp(False()) = BOOL().
            typeOfExp(Int(_)) = INT().
            typeOfExp(Add(e1, e2)) = INT() :-
              typeOfExp(e1) == INT(),
              typeOfExp(e2) == INT().
        \end{minted}
        \caption{\label{fig:statix-basic-rules}Statix predicates and rules for typing Booleans, integers and addition}
      \end{figure}

    \subsection{Building a Scope Graph}
    \subsection{Querying the Scope Graph}

    % \begin{figure}[htb]
    %   \tikzstyle{refdec}   = [rectangle, minimum width=.6cm, minimum height=.6cm, text centered, draw=black, fill=black!5, font=\ttfamily]
    %   \tikzstyle{scope}    = [ellipse,   minimum width=.9cm, minimum height=.9cm, text centered, draw=black, font=\ttfamily]

    %   \tikzstyle{P}          = [thick,-{Triangle}, font=\ttfamily]
    %   \tikzstyle{refdecedge} = [-{Triangle}, font=\ttfamily]
    %   \tikzstyle{I}          = [-{Triangle[open]}, font=\ttfamily]

    %   \begin{tikzpicture}
    %     \node (s_0) 	[scope] 	at(-8.000000, 0.000000) {s1};
    %     \node (x_1) 	[refdec] 	at(-6.000000, 0.000000) {x};
    %     \node (s_2) 	[scope] 	at(-8.000000, -2.000000) {s2};
    %     \node (x_3) 	[refdec] 	at(-6.000000, -2.000000) {x};
    %     \node (y_4) 	[refdec] 	at(-6.000000, -4.000000) {y};
    %     \node (z_5) 	[refdec] 	at(-6.000000, -5.000000) {z};


    %     \draw[refdecedge] 	(s_0.east) 	-- (x_1.west);
    %     \draw[refdecedge] 	(s_2.south) 	-- (z_5.west);
    %     \draw[P] 	(s_2.north) 	-- (s_0.south) 	node[pos=0.5, xshift=-1ex] {P};
    %     \draw[refdecedge] 	(s_2.south east) 	-- (y_4.west);
    %     \draw[refdecedge] 	(x_3.west) 	-- (s_2.east);
    %   \end{tikzpicture}
    %   \caption{ This is a caption}
    % \end{figure}
  
  \section{\label{sec:simple-type-systems}Encoding the WebDSL Basics}

    \subsection{\label{subsec:simple-constants}Constant Expressions}

      \begin{itemize}
        \item Typing rules
        \item Type compatibility
      \end{itemize}

    \subsection{\label{subsec:simple-variables}Variables}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Declare before use
        \item Shadowing
      \end{itemize}

    \subsection{\label{subsec:simple-entities}Entities and properties}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{\label{subsec:simple-functions}Functions}

      \begin{itemize}
        \item Declaration and resolving
        \item Prevent duplicates
        \item Parameters
      \end{itemize}

    \subsection{\label{subsec:simple-pages}Pages and Templates}

      \begin{itemize}
        \item Declaration and resolving
      \end{itemize}

  \section{\label{sec:inheritance}Inheritance}

    \subsubsection{Linking the Scopes}
      The implementation of inheritance requires the scope of the sub- and super-entity to be connected such that Statix queries can resolve to declarations from the super-entity when necessary. To achieve this, we introduce an edge label \texttt{INHERIT} as shown in listing \emph{TO-DO}.
      \begin{minted}[firstline=3]{\statix}
        module x
        signature
          name-resolution
            labels
              INHERIT // inherit edge label for subclasses
      \end{minted}
      Declarations of sub-entities will generate constraints as shown in listing \emph{TO-DO}.
      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity super' s_super}
            resolveEntity(s_global, super) == [(_, (super', ENTITY(s_super)))],
            new s_entity, s_entity -INHERIT-> s_super,
            noCircularInheritance(s_entity),
            declEntity(s_global, s_entity, x, bodydecs),
            @super.ref := super'.
      \end{minted}
      First of all, the super-entity refered to in the declaration must refer to an existing entity in the scope graph. Secondly, the new scope belonging to the sub-entity \texttt{s\_entity} is linked to the scope of the super class \texttt{s\_super} via an \texttt{INHERIT} edge. Finally, some additional constraints are generated to make sure no circular inheritance exists and constraints for the entity body declarations of the sub-entity are generated.

      Previously, the resolving of variables was done using the query as shown in listing \emph{TO-DO}
      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          resolveVar(s, x) = ps :-
            query var filter P* F* IMPORT*
                      and { x' :- x' == (x, _) }
                      min $ < P, P < F, F < IMPORT
                      and true
                      in s |-> ps.
      \end{minted}
      The new query in listing \emph{TO-DO} reflects the addition of the \texttt{EXTEND} label. The addition of \texttt{INHERIT*} in the query filter makes all variables declared in ancestors reachable.
      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          resolveVar(s, x) = ps :-
            query var filter P* F* INHERIT* IMPORT*
                      and { x' :- x' == (x, _) }
                      min $ < P, P < F, F < INHERIT, INHERIT < IMPORT
                      and true
                      in s |-> ps.
      \end{minted}

    \subsubsection{Overwriting Functions}
      Generally, overwriting functions is not allowed in WebDSL. Entity functions are an exception to this such that entity function definitions shadow global function definitions. With the introduction of inheritance there comes another exception, namely that sub-entities are allowed to overwrite function definitions of their ancestors.

      Previously, the resolving of entity functions was done using the query as shown in listing \emph{TO-DO} below.

      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          resolveEntityFunction(s, x) = ps :-
            query function filter e
                            and { x' :- x' == (x, _) }
                            min
                            in s |-> ps.
      \end{minted}

      With the introduction of entity inheritance, the path well-formedness over edge labels should be tweaked such that functions from ancestors are in scope. Changing \texttt{filter e} to \texttt{filter INHERIT*} accomplishes this. The resulting query is in listing \emph{TO-DO} below.

      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          resolveEntityFunction(s, x) = ps :-
            query function filter INHERIT*
                            and { x' :- x' == (x, _) }
                            min /* */
                            in s |-> ps.
      \end{minted}

      This query definition works perfectly when sub-entities do not overwrite functions. When a sub-entity does define a function that is already defined in one of its ancestors, resolving the entity function gives two results while we would like only one result, namely the overwritten function defined in the sub-entity. To tackle this challenge, we defined a Statix anonymous shadowing rule combined with a label order. This ensures that when two functions with the same name and argument types exist, only the most specific (i.e. the least inheritance edges) is returned. This is implemented as shown in listing \emph{TO-DO}.

      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          resolveEntityFunction(s, x) = ps :-
            query function filter INHERIT*
                            and { x' :- x' == (x, _) }
                            /* prioritize local scope over inheritance */
                            min $ < INHERIT
                            /* shadow when function name and argument types match */
                            and {
                            (f, FUNCTION(args, _, _)),
                            (f, FUNCTION(args, _, _))
                            }
                            in s |-> ps.
      \end{minted}

    \subsubsection{Entity Type Compatibility}
      A great perk of having inheritance in a language is writing code for that works for super-entities, and then executing this code with sub-entities. To know if the given entity type is compatible with the required entity type, we require a predicate that defines this compatibility. We have created such a predicate while implementing general type compatibility in subsection \emph{TO-DO}, in the form of \lstinline|typeCompatibleB : TYPE * TYPE -> BOOL|.

      With the addition of entity inheritance, we need to expand this definition. To this end, we added the rules as shown in listing \emph{TO-DO}. Given two entity scopes, the \lstinline|inherits(s_sub, s_super)| predicate returns true when the query has one result. The query in the \texttt{inherits} rule requests all paths from scope \texttt{s\_sub} to scope \texttt{s\_super} consisting of only \texttt{INHERIT} edges. Such a path exists if and only if the entity belonging to scope \texttt{s\_sub} inherits the entity belonging to \texttt{s\_super}.

      \begin{minted}[firstline=3]{\statix}
        module x
        rules
          typeCompatibleB(ENTITY(s_sub), ENTITY(s_super)) = inherits(s_sub, s_super).

          inherits : scope * scope -> BOOL
          inherits(s_sub, s_super) = nonEmptyPathScopeList(ps) :-
            query () filter INHERIT*
                      and { s :- s == s_super }
                      min $ < INHERIT
                      in s_sub |-> ps.

          nonEmptyPathScopeList : list((path * scope)) -> BOOL
          nonEmptyPathScopeList(_)       = FALSE().
          nonEmptyPathScopeList([(_,_)]) = TRUE().
      \end{minted}

  \section{\label{sec:entity-extension}Entity Extension}

    \subsection{\label{subsec:type-extension}Built-in Type Extension}

  \section{\label{sec:function-template-overloading}Function and Template Overloading}

  \section{\label{sec:module-system}Module system}

  \section{\label{sec:built-in-library}Pre-analyzed built-in library}

  \section{\label{sec:statix-reflection}Reflection on Statix}

    \begin{itemize}
      \item Repeat reasons for using Statix
      \item What worked out as intended?
      \item What did not work as intended?
      \item What are the workarounds?
      \item Recommendations for improving Statix
    \end{itemize}
