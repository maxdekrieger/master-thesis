% !TEX root = document.tex

\chapter{\label{chap:related-work}Related work}

  In this chapter we discuss work related to compiler front-ends of domain-specific languages. First, we examine published research related to WebDSL that address its grammar and static analysis. Second, we examine work concerning SDF3 and Statix and recent case studies using these meta languages. To conclude, we discuss related work on language workbenches other than Spoofax.

  \section{WebDSL}

    The paper of Visser (\citeyear{Visser2007}) introduced WebDSL as a case study of Stratego. The work lists most language constructs of the first WebDSL version, combined with SDF2 snippets of their syntax and Stratego code that demonstrates how code is generated for the WebDSL construct. Despite type checking not being mentioned for all language constructs, an extensive example plus implementation in Stratego is given for typechecking a for-loop and the declaration and resolving of a variable is WebDSL. Other work by Groenewegen and Visser present linguistically integrated extensions of WebDSL regarding access control (\citeyear{GroenewegenV08}) and data validation (\citeyear{GroenewegenV13}).

    The work of Hemel et al. (\citeyear{Hemel2011}) identifies static consistency checking as lacking for web frameworks that were modern at the time and they provide an analysis of how the web frameworks deal with certain consistency checks. Hemel et al. argue that domain-specific languages should be designed for consistency checking, providing a deep-dive on WebDSL as example. Additionally, they present how to perform such consistency checks with Stratego, essentially explaining an early version of the current WebDSL static analysis in Stratego.

    The latest publication on WebDSL by Groenewegen et al. (\citeyear{Groenewegen2020}) reflects on the WebDSL language as a whole, and provides an experience report of using WebDSL for over 10 years for increasingly ambitious applications.

  \section{Statix}

    Scope graphs were introduced by Neron et al. (\citeyear{Neron2015}) as a language-independent framework for describing name binding in programming languages. Van Antwerpen et al. (\citeyear{AntwerpenNTVW16}) build upon this work and extend the scope graph framework with generalized edge labels and introduce a constraint language with a solver that is able to express name binding and typing constraints. In a subsequent publication, Van Antwerpen et al. (\citeyear{VanAntwerpen2018}) further extend the scope graph framework to increase the range of language constructs that can be modelled, such as parameterized types. Additionally, this work introduces Statix as a declarative language to specify type systems. In later work, the performance of Statix was boosted by Van Antwerpen and Visser (\citeyear{AntwerpenV21}) through the introduction of the concurrent Statix solver, and by Zwaan et al. (\citeyear{ZwaanAV22}) who introduced an incremental Statix solver.

    \subsection{Case Studies}

      The paper that introduced scope graphs by Neron et al. (\citeyear{Neron2015}) contains several illustrations on how scope graphs can model the name binding structure of programs. In the paper, the authors illustrate how to model various concepts of the Language with Modules and Records (LMR) such as let-bindings and, unsurprisingly, modules and records. The extended version (\citeyear{TUD-SERG-2015-001}) contains examples on definition-before-use, Java packages and imports and C\# partial classes. Van Antwerpen et al. (\citeyear{AntwerpenNTVW16}) use the LMR example again, but in addition to showing the scope graph, they list the typing constraints for certain snippets, and show an algorithm with rules that dictate how to traverse any LMR program and generate constraints.

      The work that introced Statix \autocite{VanAntwerpen2018} contained case studies on simply-typed lambda calculus that shows records and structural subtyping, Featherweight Java that presents classes and nominal subtyping. Lastly, the paper contains a case study on System F that illustrates Statix' ability to deal with parametric polymorphism.

      The research of Rouvoet et al. (\citeyear{RouvoetAPKV20}) on sound scheduling of name resolution queries also contains various case studies of languages used in practice, modelled in MiniStatix: the core constraint language of Statix, with some extras implemented in Haskell. The case studies are on a subset of name resolution for Java and scala, and the whole of LMR. In their evaluation they used a combination of valid and invalid programs, similar to this thesis. In contrast to this thesis, Rouvoet et al. do not use error message expectations, simply a fail or succeed expectation but the aim of their evaluation was different than ours. 

      Van Antwerpen et al. (\citeyear{AntwerpenV21}) implement a subset of Java in Statix to evaluate their work on real-world codebases, similar to what we show in this thesis. However, their work is not evaluated on erroneous programs, as their goal is to benchmark the parallel Statix solver in terms of run time.

      In addition to published research, there are multiple Master's theses that contain Statix case studies:

      \textbf{Aerts (\citeyear{Aerts2019}): Incrementalizing Statix: A Modular and Incremental Approach for Type Checking and Name Binding using Scope Graphs.}

      \begin{itemize}
        \item Incrementalizing Statix
        \item Case study: extremely minimal Java
      \end{itemize}
  
      \textbf{Zwaan (\citeyear{Zwaan2021}): Composable Type System Specification using Heterogeneous Scope Graphs.}
      
      \begin{itemize}
        \item Composing Statix specifications
        \item Case study: Mini-SDF + Mini-Stratego
        \item Case study: Mod + Mini-SQL
      \end{itemize}
  
      \textbf{Wilms (\citeyear{Wilms2022}): Extending the Domain Specific Language for the Pipelines for Interactive Environments build system.}

      \begin{itemize}
        \item Case study: PIE DSL 2 in Statix
      \end{itemize}
    
  \section{Other Language Workbenches}

  \section{Subjects to investigate}

    \begin{itemize}
      \item MPS CodeRules
      \begin{itemize}
        \item Constraint programming for MPS
      \end{itemize}
      \item https://github.com/JetBrains/mps-coderules
    \end{itemize}

  \section{Papers to investigate}

    \begin{itemize}
      \item Type errors for the IDE with Xtext and Xsemantics
      \begin{itemize}
        \item https://www.degruyter.com/document/doi/10.1515/comp-2019-0003/html
        \item 2019, journal Open Computer Science
        \item Implements typechers for two small languages with the Xtext language workbench
        \item Describes what to pay attention to when implementing a typechecker (error recovery, useful error messages, etc.)
        \item Key difference: This thesis contains a larger case study and is written in Spoofax meta-languages
      \end{itemize}
      \item Xbase: implementing domain-specific languages for Java
      \begin{itemize}
        \item https://dl.acm.org/doi/abs/10.1145/2480361.2371419
        \item 2012, GPCE '12 (Generative Programming and Component Engineering)
      \end{itemize}
      \item Migrating custom DSL implementations to a language workbench (tool demo)
      \begin{itemize}
        \item https://dl.acm.org/doi/abs/10.1145/3276604.3276608
        \item 2018, SLE '18 (Software Language Engineering)
      \end{itemize}
      \item The State of the Art in Language Workbenches
      \begin{itemize}
        \item https://link.springer.com/chapter/10.1007/978-3-319-02654-1\_11
        \item 2013, SLE '13 (Software Language Engineering)
        \item 
      \end{itemize}
      \item Evaluating and comparing language workbenches: Existing results and benchmarks for the future
      \begin{itemize}
        \item https://www.sciencedirect.com/science/article/pii/S1477842415000573
        \item 2015, journal Computer Languages Systems \& Structures
      \end{itemize}
      \item Towards a Spreadsheet-Based Language Workbench
      \begin{itemize}
        \item https://ieeexplore.ieee.org/abstract/document/9643797
        \item 2021, MODELS-C '21 (Model Driven Engineering Languages and Systems Companion)
      \end{itemize}
      \item Language Workbench Support for Block-Based DSLs
      \begin{itemize}
        \item https://core.ac.uk/download/pdf/301639649.pdf
        \item 2018, BLOCKS+ in SPLASH '18 (Systems, Programming, Languages and Applications: Software for Humanity)
      \end{itemize}
    \end{itemize}